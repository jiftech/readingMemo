# 7つの言語 7つの世界 第3章
[全体目次へ戻る](index.md)

## 第3章 Io
Ioを有名人に喩えると｢フェリス･ビューラー｣。

> 問題は｢何をするか｣ではない。｢何をしないか｣だ。

## 3.1 Ioとは
- 2002年にSteve Dekorte氏によって開発された、**プロトタイプ言語**
  + LuaやJavaScriptと同様
- もともと趣味レベルの言語として生まれた小さな言語だが、ライブラリによって豊富な機能が実現されている。
- 強み: カスタマイズ可能なシンタックス･関数、強力な並行性モデル

## 3.2 1日目: 学校をさぼって、気ままに過ごす
[io language(公式ページ)](http://iolanguage.org/)
- Ioの特徴
  + 言語の構文は単純でローレベル。メッセージ(オブジェクトを返すもの)を繋げていくだけ
  + オブジェクトをクローンして新たなオブジェクトを生成する。このアプローチをプロトタイプベースと呼ぶ。

### 手始めに
- Hello, Worldプログラム
  + 文字列に`print`メッセージを送信

```io
"Hi ho, Io" print
# Hi ho, Io==> Hi ho, Io
```

- 既存のオブジェクトを複製して新しいオブジェクトを作る。このとき、既存のオブジェクトのことを｢プロトタイプ｣という。
  + 例: ルートレベルのオブジェクト`Object`を複製(`clone`メッセージを送信)し、`Vehicle`に代入

```io
Vehicle := Object clone
```

- オブジェクトは、｢スロット｣というキーと値の組を複数持てる。スロットへの代入には`:=`を使う。存在しないスロットは自動的に作成される。(`=`を使うこともできるが、この場合スロットが自動作成されず、エラーになる)
  + 例: `Vehicle`に`description`スロットを作成し文字列を代入→それに別の文字列を代入し更新

```io
Vehicle description := "Something to take you place"
Vehicle description =  "Something to take you far away"
```

- スロットの内容を取得するには、オブジェクトにスロットの名前を送信する。

```io
Vehicle description
# ==> Something to take you far away
```

- オブジェクトとは、単なるスロットの集まりである。オブジェクトが持つスロットの一覧を取得するには、`slotNames`メソッドを送信する。

```io
Vehicle slotNames
# ==> list("type", "description")
```

### オブジェクト、プロトタイプ、継承
`Vehicle`に属する｢車(`Car`)｣のインスタンスである｢`ferrari`｣オブジェクトをモデル化する方法
- まず`Vehicle`をクローンして`Car`オブジェクトを生成する。

```io
Car := Vehicle clone
Car slotNames
# ==> list("type")
Car type
# ==> Car
```

- ここで`Car`に`description`を送信する。`Car`はこのスロットを持っていない。するとIoはメッセージをプロトタイプである`Vehicle`へ転送し、ここにスロットがあるのを見つける。

```io
Car description
# ==> Something to take you far away
```

- 新しく`ferrari`オブジェクトを`Car`を複製して生成する。Ioの慣習では、オブジェクト名の先頭が大文字のものを｢タイプ｣とし、`type`スロットを設定する。小文字で始まるオブジェクトは、その親(プロトタイプ)のタイプを持つようになる。

```io
ferrari := Car clone
ferrari slotNames
# ==> list()
farrari type
# ==> Car
```

- タイプであるオブジェクトとそうでないオブジェクトとの間には、`type`スロットが存在するかしないか以外の違いはない。
  + クラスベースの言語では、クラスとオブジェクトは別物である。

まとめ:
  - オブジェクトはスロット(キー･値の組)の集まり
  - オブジェクトが持つスロットを取得するには、その名前をオブジェクトに送信する
  - 要求されたスロットがオブジェクトになければ、そのプロトタイプを探しに行く

### メソッド
- メソッドを定義するには以下のようにする。メソッドもオブジェクトであり、タイプは`Block`。

```io
method("So, you've come for an argument." println)
method() type
# ==> block
```

- メソッドをスロットに代入し、オブジェクトの一部にすることができる。メソッドが代入されているスロットを呼び出すと、メソッドが呼び出される。

```Io
Car drive := method("Vroom" println)
ferrari drive
# ==> Vroom
```

- 引数に指定した名前のスロットの内容を取得する`getSlot`というメソッドがあり、スロットの中身がメソッドならメソッドの内容を確認できる(普通にやるとメソッドが呼び出される)。

```io
ferrari getSlot("drive")
# ==> method(...メソッドの内容...)
```

- 特定のオブジェクトのプロトタイプがどれなのかを調べるには`proto`メソッドを使う。

```io
ferrari proto
# ==> Car_0x.....
Car proto
# ==> Vehicle_0x.....
```

- `Lobby`という名前空間の元締めがあり、すべての名前がついたオブジェクトがここに登録される。

#### プロトタイプ･プログラミングの基本的ルールまとめ
- すべての **モノ** はオブジェクト
- オブジェクトとのすべての **やり取り** はメッセージによって行う
- プロトタイプとなる他のオブジェクトを複製することでオブジェクトを生成する
- オブジェクトは自身のプロトタイプを記憶している
- オブジェクトにはスロットがあり、オブジェクト(値やメソッド)を格納している
- メッセージによってスロットが保持している値を取得したり、メソッドを呼び出したりする
- オブジェクトは、自分が応答できないメッセージを自分のプロトタイプに転送する

### リストとマップ
- Ioのリストは任意のタイプのオブジェクトの順序付きコレクションである。
 + リストを作成するには、`list`メソッドを用いる。リストに要素を追加するには`append`を用いる。

```io
toDos := list("find my car", "find Continuum Transfunctioner")
toDos size
# ==> 2
toDos append("find a present")
```

- すべてのリストのプロトタイプが`List`である。これには多くの便利なメソッドが用意されている。

```io
list(1, 2, 3, 4) average
# ==> 2.5

list(1, 2, 3, 4) sum
# ==> 10

list(1, 2, 3) at(1)
# ==> 2

list(1, 2, 3) append(4)
# ==> list(1, 2, 3, 4)

list(1, 2, 3) pop
# ==> 3

list(1, 2, 3) prepend(0)
# ==> list(0, 1, 2, 3)

list() isEmpty
# ==> true
```

- Ioにはマップというコレクションがあり、これはRubyのハッシュに似ている。
  + マップを作成するには、`Map`オブジェクトを複製する。

```io
elvis := Map clone

elvis atPut("home", "Graceland")

elvis at("home")
# ==> Graceland

elvis asObject
# ==> Object_0x..... home = "Graceland"

elvis asList
# ==> list(list("home", "Graceland"))

elvis keys
# ==> list("home")

elvis size
# ==> 1
```

### true, false, nil, singleton
Ioの条件判定は他のオブジェクト指向言語とほぼ同じ。
- Rubyと同じく、0は`true`である。

- `true`,`false`,`nil`はシングルトンである。これらのクローンを作成すると、シングルトン値が返る。

```io
true clone
# ==> true
```

- シングルトンを自分で作成するには、`clone`を再定義してある1つのオブジェクトを返すようにすれば良い。
  + シングルトンのクローンはすべて等しいオブジェクトとなるようにする。

```io
Highlander := Object clone
Highlander clone := Highlander
```
- Ioでは、言語を定義するようなオブジェクトのスロットまでも簡単に書き換えることができるので、自由にドメイン固有言語を作成できる。

### セルフスタディ 1日目
- Ioは強く型付けされた言語である。
- 0も空文字列("")も真である。`nil`は偽である。
- プロトタイプに存在するスロットを確認するには`obj proto slotNames`とすればよい。
- `::=`は、スロットを作成して代入すると同時に、セッターメソッド`setA`(例)を自動生成する。
- ファイルからIoのプログラムを実行するには`$ io example.io, ...`のようにする。
  + オプションに`-i`を指定すると、ファイルを読み込んでからインタプリタを起動する。
- スロットの名前を指定して格納されているコードを実行するには、`getSlot`してスロット名を指定し、`call`で実行する。

## 3.3 2日目: ソーセージキング
### 条件とループ
Ioの条件文はすべてシンタックスシュガーなしで実装されている。
- 単純な無限ループ: `loop`

```io
loop("getting dizzy..." println)
```

- 条件付きループ: `while`
 + 第1引数に条件、第2引数に実行するメッセージをとる
 + セミコロンは2つの異なるメッセージを連結する

```io
i := 1
while(i <= 11, i println; i = i + 1); "This one goes up to 11" println
# 1
# 2
# ...
# 11
# This one goes up to 11
```

- 条件付き繰り返し: `for`
  + カウンタ名、初期値、終了値(、増分)、メッセージを引数に取る。

```io
for(i, 1, 11, i println); "This oen goes up to 11" println
# 1
# 2
# ...
# 11
# This one goes up to 11
```

- Ioではオプション引数が必ずしも引数リストの最後に来るとは限らない。
- if文は2つの形式がある。前者は1つの関数、後者はメッセージの連鎖で実現されている。

```io
if(true, "It is true.", "It is false.")
# ==> It is true.

if(false) then("It is true." println) else("It is false." println)
# It is false.
```

### 演算子
- Ioの演算子を確認するには演算子表を呼び出す`OperatorTable`を使う。通常の演算子と代入演算子は別枠である。
- 演算子を追加することもできる。以下の例は新たに`xor`演算子を定義する。
  + まず演算子表に`xor`を追加する。
  + 次に`true`および`false`を拡張してメソッド`xor`を実装する。

```io
# 演算子表に追加
OperatorTable addOperator("xor", 11)
# trueとfalseにxorを実装
true xor := method(bool, if(bool, false, true))
false xor := method(bool, if(bool, true, false))
# 確認
true xor true
# ==> false
...
```

### メッセージ
Ioでは、コメントマーカーおよび引数間のカンマ以外はすべてメッセージである。基本的な呼び出し方以外にも、様々なメッセージの呼び出し方がある。
- メッセージのリフレクション: メッセージの性質を問い合わせて、それに応じて処理を実行することができる。
  + メッセージは`sender`(送信元)、`target`(宛先)、`arguments`(引数)の3つの要素からなる。`call`メソッドを使うと、これらの情報を参照できる。

- メッセージの引数は評価されずにレシーバに渡されて、レシーバの方で評価される。制御構造をメッセージで実装することができる。
  + `doMessage`は引数のメッセージを実行する。
  + `argAt(n)`はメッセージの引数のn番目の引数を取り出す。
  + 下のコードでは、まず`sender 1 == 2`が実行され`false`が返る。よって`ifFalse`が実行されるが、そこでは`sender writeln("...")`が実行され、文字列が出力される。`ifFalse`は`false`を返すので、`ifTrue`は何もせず終了する。

```io
unless := method(
  (call sender doMessage(call message argAt(0))) ifFalse(
  call sender doMessage(call message argAt(1))) ifTrue(
  call sender doMessage(call message argAt(2)))
)

unless(1 == 2, writeln("one is not two"), writeln("one is two"))
# one is not two
```

### リフレクション
[プロトタイプチェーンを辿って順番にスロット名を出力していくプログラム](example/animals.io)
- `self`でオブジェクト自身を返せる。

## 3.4 3日目: パレードとその他の奇妙な場所
### ドメイン固有言語
Ioでは演算子からシンボルまで、言語を構成するもの全てを再定義できるので、DSLの設計がしやすい。

[電話帳を表現したテキストファイルを読み込んでIo内部データ構造に変換するプログラム](example/io/phonebook.io)
- `:`が`atPutNumber`というメソッドと解釈されるように演算子テーブルを変更している。
- `curlyBrackets`メソッドは、プログラム中に中括弧"{}"が現れたときに、その中身を引数と解釈して実行されるメソッド。
  + ここでは、中括弧に出会ったらまずMapを初期化し、中括弧の中身(=引数)それぞれをメッセージと解釈して初期化したMapに送信していき、最後にMapを返す、という処理に書き換えている。

```io
# 以下の2つは等価
{a, b, c}
curlyBrackets(a, b, c)
```

- `atPutNumber`メソッドをMapに追加する。このメソッドは、Map自身に｢第1引数から引用符を除いたもの｣と｢第2引数｣の組を追加する。
  + 最初に`:`を`atPutNumber`に書き換えているので、例えば以下のような動作をすることになる。

```io
map ("hoge" : "1234567890")
# mapに｢hoge｣と｢1234567890｣の組が追加される
```

- 最後の4行では新しく定義したDSLを試している。`s`には指定したテキストファイルの中身が入る。`doString`の引数に文字列を渡すと、その文字列をコードとして評価する。

### Ioのmethod_missing
Ioでは、メッセージを処理する動作は以下のように定義されている。
1. 引数を計算する
2. メッセージの名前、送信先、送信元を取得する
3. 送信先のスロットにメッセージの名前と一致するものがないか調べる
4. スロットがあれば、データを返す･メソッドを呼び出す
5. スロットがなければ、メッセージをプロトタイプに転送する

`forward`メッセージを上書きすることで、存在しないメッセージが送信されたときの動作(つまり5.の動作)を変更することができる。これをRubyの`method_missing`のように利用することができる。

["LispML"をXMLに変換するプログラム](example/io/builder.io)

### 並行性
#### コルーチン
コルーチンを使うと、プロセスの実行を好きな時点で停止･再開できる。
- `yield`を呼び出すたびに、そのプロセスが停止され、別のプロセスに制御が移る。
- メッセージを非同期に送信するには、メッセージの前に`@`または`@@`を付ける。`@`はフューチャを返す。`@@`は新しいスレッドを立ててメッセージを開始する。
- `pause`によって全ての非同期メッセージの終了を待つことができる。

[2つのメソッド(コルーチン)を並列動作させるプログラム](example/io/coroutine.io)

#### アクター
アクターとは、受信したメッセージをキューにためてコルーチンで実行したり、他のアクターにメッセージを送信したりするもので、それぞれのアクターは非同期に動作する。アクターの状態は、厳密に管理されたキューを介してのみ変更できる(cf. スレッドの状態は制限なしに自由に変更できる→競合状態が発生する)。

Ioでは、非同期のメッセージをオブジェクトに送信する **だけ** で、そのオブジェクトがアクターとして動作するようになる。

#### フューチャ
フューチャとは、非同期のメッセージ呼び出しによってすぐに返されるオブジェクトで、プロセスが終了するとそのプロセスの結果に"すり替わる"(ここが他の言語とは一味違う)。プロセスが終了する前にフューチャの値を得ようとすると、結果が出るまでブロックされる。

## 3.5 Ioのまとめ
### 長所
- プロトタイプ言語であり、柔軟性が高い。全てのオブジェクトの全てのスロットの中身を変更できるので、独自の構文をすぐに作成できる。
- コンパクトで、実行に必要なメモリが少ないので、組込みシステムで利用しやすい。
- 構文がシンプル。
- 並行性に関して、JavaやRubyとは違った新しい概念を導入しているので、マルチスレッドアプリケーションを簡単に書ける。

### 短所
- シンタックスシュガーがほとんどなく、難しい概念を簡単な構文で表現するのが難しい。
- コミュニティが小さい。
- シングルスレッドでの実行速度はあまり速くない。

***


[前へ](c2.md) /
[全体目次へ戻る](index.md) /
[次へ](c4.md)
