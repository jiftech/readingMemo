# 7つの言語 7つの世界 第3章
[全体目次へ戻る](index.md)

## 3章 Io
Ioを有名人に喩えると｢フェリス･ビューラー｣。

> 問題は｢何をするか｣ではない。｢何をしないか｣だ。

## 3.1 Ioとは
- 2002年にSteve Dekorte氏によって開発された、**プロトタイプ言語**
  + LuaやJavaScriptと同様
- もともと趣味レベルの言語として生まれた小さな言語だが、ライブラリによって豊富な機能が実現されている。
- 強み: カスタマイズ可能なシンタックス･関数、強力な並行性モデル

## 3.2 1日目: 学校をさぼって、気ままに過ごす
[io language(公式ページ)](http://iolanguage.org/)
- Ioの特徴
  + 言語の構文は単純でローレベル。メッセージ(オブジェクトを返すもの)を繋げていくだけ
  + オブジェクトをクローンして新たなオブジェクトを生成する。このアプローチをプロトタイプベースと呼ぶ。

### 手始めに
- Hello, Worldプログラム
  + 文字列に`print`メッセージを送信

```io
Io> "Hi ho, Io" print
# Hi ho, Io==> Hi ho, Io
```

- 既存のオブジェクトを複製して新しいオブジェクトを作る。このとき、既存のオブジェクトのことを｢プロトタイプ｣という。
  + 例: ルートレベルのオブジェクト`Object`を複製(`clone`メッセージを送信)し、`Vehicle`に代入

```io
Io> Vehicle := Object clone
```

- オブジェクトは、｢スロット｣というキーと値の組を複数持てる。スロットへの代入には`:=`を使う。存在しないスロットは自動的に作成される。(`=`を使うこともできるが、この場合スロットが自動作成されず、エラーになる)
  + 例: `Vehicle`に`description`スロットを作成し文字列を代入→それに別の文字列を代入し更新

```io
Io > Vehicle description := "Something to take you place"
Io > Vehicle description =  "Something to take you far away"
```

- スロットの内容を取得するには、オブジェクトにスロットの名前を送信する。

```io
Io > Vehicle description
# ==> Something to take you far away
```

- オブジェクトとは、単なるスロットの集まりである。オブジェクトが持つスロットの一覧を取得するには、`slotNames`メソッドを送信する。

```io
Io > Vehicle slotNames
# ==> list("type", "description")
```

### オブジェクト、プロトタイプ、継承
`Vehicle`に属する｢車(`Car`)｣のインスタンスである｢`ferrari`｣オブジェクトをモデル化する方法
- まず`Vehicle`をクローンして`Car`オブジェクトを生成する。

```io
Io > Car := Vehicle clone
Io > Car slotNames
# ==> list("type")
Io > Car type
# ==> Car
```

- ここで`Car`に`description`を送信する。`Car`はこのスロットを持っていない。するとIoはメッセージをプロトタイプである`Vehicle`へ転送し、ここにスロットがあるのを見つける。

```io
Io > Car description
# ==> Something to take you far away
```

- 新しく`ferrari`オブジェクトを`Car`を複製して生成する。Ioの慣習では、オブジェクト名の先頭が大文字のものを｢タイプ｣とし、`type`スロットを設定する。小文字で始まるオブジェクトは、その親(プロトタイプ)のタイプを持つようになる。

```io
ferrari := Car clone
ferrari slotNames
# ==> list()
farrari type
# ==> Car
```

- タイプであるオブジェクトとそうでないオブジェクトとの間には、`type`スロットが存在するかしないか以外の違いはない。
  + クラスベースの言語では、クラスとオブジェクトは別物である。

まとめ:
  - オブジェクトはスロット(キー･値の組)の集まり
  - オブジェクトが持つスロットを取得するには、その名前をオブジェクトに送信する
  - 要求されたスロットがオブジェクトになければ、そのプロトタイプを探しに行く

### メソッド
- メソッドを定義するには以下のようにする。メソッドもオブジェクトであり、タイプは`Block`。

```io
Io > method("So, you've come for an argument." println)
Io > method() type
# ==> block
```

- メソッドをスロットに代入し、オブジェクトの一部にすることができる。メソッドが代入されているスロットを呼び出すと、メソッドが呼び出される。

```Io
Io > Car drive := method("Vroom" println)
Io > ferrari drive
# ==> Vroom
```

- 引数に指定した名前のスロットの内容を取得する`getSlot`というメソッドがあり、スロットの中身がメソッドならメソッドの内容を確認できる(普通にやるとメソッドが呼び出される)。

```io
Io > ferrari getSlot("drive")
# ==> method(...メソッドの内容...)
```

- 特定のオブジェクトのプロトタイプがどれなのかを調べるには`proto`メソッドを使う。

```io
Io > ferrari proto
# ==> Car_0x.....
Io > Car proto
# ==> Vehicle_0x.....
```

- `Lobby`という名前空間の元締めがあり、すべての名前がついたオブジェクトがここに登録される。

#### プロトタイプ･プログラミングの基本的ルールまとめ
- すべての **モノ** はオブジェクト
- オブジェクトとのすべての **やり取り** はメッセージによって行う
- プロトタイプとなる他のオブジェクトを複製することでオブジェクトを生成する
- オブジェクトは自身のプロトタイプを記憶している
- オブジェクトにはスロットがあり、オブジェクト(値やメソッド)を格納している
- メッセージによってスロットが保持している値を取得したり、メソッドを呼び出したりする
- オブジェクトは、自分が応答できないメッセージを自分のプロトタイプに転送する

### リストとマップ
- Ioのリストは任意のタイプのオブジェクトの順序付きコレクションである。
 + リストを作成するには、`list`メソッドを用いる。リストに要素を追加するには`append`を用いる。

```io
Io > toDos := list("find my car", "find Continuum Transfunctioner")
Io > toDos size
# ==> 2
Io > toDos append("find a present")
```

- すべてのリストのプロトタイプが`List`である。これには多くの便利なメソッドが用意されている。

```io
Io > list(1, 2, 3, 4) average
# ==> 2.5

Io > list(1, 2, 3, 4) sum
# ==> 10

Io > list(1, 2, 3) at(1)
# ==> 2

Io > list(1, 2, 3) append(4)
# ==> list(1, 2, 3, 4)

Io > list(1, 2, 3) pop
# ==> 3

Io > list(1, 2, 3) prepend(0)
# ==> list(0, 1, 2, 3)

Io > list() isEmpty
# ==> true
```

- Ioにはマップというコレクションがあり、これはRubyのハッシュに似ている。
  + マップを作成するには、`Map`オブジェクトを複製する。

```io
Io > elvis := Map clone

Io > elvis atPut("home", "Graceland")

Io > elvis at("home")
# ==> Graceland

Io > elvis asObject
# ==> Object_0x..... home = "Graceland"

Io > elvis asList
# ==> list(list("home", "Graceland"))

Io > elvis keys
# ==> list("home")

Io > elvis size
# ==> 1
```

### true, false, nil, singleton
***


[前へ](c2.md) /
[全体目次へ戻る](index.md) /
[次へ](c4.md)
