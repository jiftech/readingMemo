# 7つの言語 7つの世界 第4章
[全体目次へ戻る](index.md)

## 4章 Prolog
Prologは **宣言型言語** であり、命令型言語であるIoやRubyとは著しく異なる側面を持つ。命令型言語では、目的を達成するための方法をコンピュータに指示していくが、Prologのような宣言型言語では、事前に｢事実｣と｢ルール｣を記述しておき、コンピュータに質問をし、推論をさせるというアプローチで問題を解決する。

> 言ってみれば、(自分でケーキを焼く代わりに)おいしいケーキ屋さんに行くようなものだ。食べたいケーキの特徴を記述すると、与えられたルールに基づいて、ケーキ屋さんが材料を選び、ケーキを焼いてくれる。

Prologを人物に例えれば『レインマン』に登場する｢レイモンド｣である。Prologに対しても、レイモンドに対しても。｢なぜ分かったのか｣と｢なぜ分からないのか｣という疑問を、同じくらいの割合で抱くことになる。正しい方法で質問をしなければ、素晴らしい答えは得られない。

### 4.1 Prologについて
- Alain ColmerauerとPhillipe Rousselによって1972年に開発された論理プログラミング言語
- SQLと同様にデータベースを扱う
- Prologが扱うデータは論理ルールと関係からなる。
- SQLと同様、データを表現する部分とデータに質問する部分に分けられる。
- Prologの構成要素は以下の3つである。
  + 事実: 特定の世界についての基本的な表明(○○は××である など)
  + ルール: 世界の事実に関する推論(○○が××であれば、その○○は△△である など)
  + 質問: その世界に関する質問(○○は△△か? など)
- 事実とルールが｢知識ベース｣を構成する。Prologコンパイラは、質問が効率的に処理できる形に知識ベースをコンパイルする。

### 4.2 1日目: 素晴らしいドライバー
- Prologにはいくつもの方言がある。以下のコード例はGNU Prolog(gprolog)を使う場合のものである

#### 基本事実
- Prologでは、小文字で始まる単語は **アトム** 、大文字またはアンダースコアで始まる単語は **変数** として区別される。
  + 変数の値は変更できるが、アトムは変更できない
- Prologでの問題解決手順
  1. 知識ベース(事実とルールの組み合わせ)をファイルに記述(拡張子は`.pl`)
  2. 知識ベースをPrologインタプリタで読み込む
  3. Prologに質問をする
- [簡単な知識ベースの例](example/prolog/friends.pl)
  + `likes(a, b)`は｢a は b が好きだ｣という事実を表す
  + `friend(X, Y)`は｢X と Y が同一でなく、さらに両方が同じものが好きなら、X と Y は友達である｣というルールを表している
- 知識ベースを読み込むには、インタプリタで`['friends.pl'].`のように入力する。
  + ファイルが正しく読みこまれた場合、Prologは`yes`を返す。
- Prologに対する最も簡単な質問の例

```prolog
?- likes(wallace, sheep).
/* no */

?- likes(grommit, cheese).
/* yes */
```

#### 基本的な推論と変数
- `friend`ルール再考

```prolog
friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).
```

- `:-`の右側のコンマで区切られた各部分を **サブゴール** という。与えられた入力を事実に照らし、全てのサブゴールが満たされる場合にPrologは`yes`を返す。
  + 1番目のサブゴールにおいて、`\+`は論理否定を表すので、これは｢XとYが等しくない｣という意味
  + 2番目と3番目のサブゴールを合わせると｢XはZが好きで、かつYもZが好きである｣という意味。

- Prologの推論の流れ

```prolog
?- friend(wendolene, grommit).
/* no */
```

- 上記のような質問をしたとき、Prologは次の2つの可能性を試してみる
  + `wendolene`, `grommit`, `cheese`
  + `wendolene`, `grommit`, `sheep`
- 結局どちらも2番目と3番目のゴールを同時に満たすことはないので、Prologは`no`を返す。

- `friend`ルールはパラメータを2つ取るので`friend/2`と呼ぶ。


#### 穴埋め問題
- 質問の中に変数を指定することで、｢質問に対して考えられる全ての答えを見つける｣こともできる。
- 例) [食べ物の種類と味を表す知識ベース](example/prolog/food.pl)
  + `food_flavor(X, Y)`は、食べ物XがZという種類でZの味がYであるとき、Xの味はYであるというルール。
- この知識ベースに対する質問の例
```prolog
?- food_type(What, meat).
/* What = spam ? */ ;
/* What = sausage ? */ ;
/* no */
```
- 上の例では、Prologに｢`meat`であるような食べ物を見つけよ｣と尋ねている。Prologは1つ目の答え(`spam`)を返す。ここで`;`を入力すると、Prologは別の答えを探し、`sausage`を見つける。さらに`;`を入力すると、Prologはまた別の答えを探すが、見つからないので`no`を返す。
  + Prologは1つの答えを見つけたときに該当する値がもう存在しないことを(推論せずに)検出した場合答えと同時に`yes`を返す。
  + 一方、｢推論の結果｣として該当する値がもう存在しないと分かった場合は`no`を返す。
- 別の質問
```prolog
?- food_flavor(What, savory).
/* What = velveeta ? */ ;
/* What = spam ? */ ;
/* What = sausage ? */ ;
/* no */
```
- この例では、｢味が`savory`(塩辛い)な食べ物を全て見つけよ｣とPrologに命令している。Prologは食べ物、種類、味の全ての組み合わせを調べることで答えを導き出す。

##### 地図の塗り分け
[米国南東部の州の地図を塗り分けるための知識ベース](example/prolog/map.pl)
- この知識ベースに対し次のように質問するだけで、Prologは適切な塗り分け方法を導き出してくれる。
```prolog
?- coloring(Alabama, Mississippi, Georgia, Tennessee, Florida).
```
- 1つの組み合わせが得られた後、全ての組み合わせを知るためには`a`を入力すれば良い。
- このように、Prologでは問題を解くためのアルゴリズムを記述するのではなく、｢事実を記述して、コンピュータに推論させる｣というアプローチで問題を解く。

#### ユニフィケーションその1
- Prologでは、変数への代入の代わりに **ユニフィケーション** を用いて推論を行う。これは｢2つの構造体を一致させようとする｣操作である。

例) [猫に関する簡単な知識ベース](example/prolog/ohmy.pl)
- 1つ目のルールを使った簡単な質問
```prolog
?- dorothy(lion, tiger, bear).
/* yes *
```
  + `dorothy`ルールの右側では、`X`,`Y`,`Z`をそれぞれ`lion`,`tiger`,`bear`にバインドする。そしてこれらの値は左側の対応する値に一致するのでユニフィケーション成功となりPrologは`yes`を返す。
- もうひと捻りした質問
```prolog
?- dorothy(One, Two, Three).
/* One = lion */
/* Two = tiger */
/* Three = bear */
/* yes */
```
  + まず`X`,`Y`,`Z`をそれぞれ`lion`,`tiger`,`bear`にバインドする。
  + 次に左辺で`X`,`Y`,`Z`をそれぞれ`One`,`Two`,`Three`にユニファイして結果を出力する。
- 2つ目のルールを使った質問と推論の流れ
```prolog
?- twin_cats(One, Two).
/* One = lion */
/* Two = lion ? */
```
  1. Prologは`One`を`X`に、`Two`を`Y`にバインドする。
  2. 各ゴールを満たすような値を調べていく。最初のゴールは`cat(X)`である。これにマッチする事実`cat(lion)`と`cat(tiger)`のうち最初の事実を試すため、`X`を`lion`にバインドする。
  3. 次のゴールに移り、`cat(Y)`の`Y`を適切な値にバインドしようとする。2.と同様適切な値は2つあるので、まず`lion`を選択する。
  4. 両方のゴールが満たされたので、ルールを成功させた`One`と`Two`の値(`lion`, `lion`)を表示する。

- ユニフィケーションを使うと、変数への代入を超えた高度なマッチングを行うこともできる(詳しくは2日目)。

### 4.3 2日目: Wapner判事まで15分
再帰、数値計算、リストの使い方について

#### 再帰
Prologでは、リストなどのコレクションを扱う際には繰り返しではなく再帰を使うことが多い。

例) [再帰的サブゴールを用いた知識ベース](example/prolog/family.pl)
- この例では、祖先関係を推論するために再帰を用いている。すなわち、`ancestor`ルール内の1つの節で再度`ancestor`を使っている。
- ルール`ancestor/2`には2つの節(ピリオドで区切られたコードのまとまり)がある。1つのルールに複数の節が含まれる場合、どれか1つの節が真であれば、そのルールは真となる。
  + サブゴールの間のコンマは"and",節の間のピリオドは"or"と考えれば良い
- この1つのルールを2つの目的、すなわち祖先を見つける場合と子孫を見つける場合に使うことができる。

```prolog
/* zebの子孫を見つける */
?- ancestor(zeb, Who).

/* john_boy_jrの祖先を見つける */
?- ancestor(Who, john_boy_jr).
```
- 再帰的サブゴールを使う場合はメモリ不足に注意する必要がある。
  + ルールの最後に再帰的サブゴールを置くことができれば、 **末尾再帰最適化** が働きメモリ使用量を一定に保つことができる。

#### リストとタプル
- リストは可変長のコレクションで、要素を角括弧で囲んで表す。 例) `[1, 2, 3]`
- タプルは固定長のコレクションで、要素を丸括弧で囲んで表す。 例) `(1, 2, 3)`

##### ユニフィケーションその2
- 2つのタプルは、要素数が同じで各要素が一致するときにマッチする。

```prolog
?- (1, 2, 3) = (1, 2, 3).
/* yes */

?- (1, 2, 3) = (1, 2, 3, 4).
/* no */
```
- 変数を含めると、両辺が一致するように各変数に値がバインドされる。変数はどちらの辺にあっても構わない。

```prolog
?- (A, B, C) = (1, 2, 3).
/* A = 1 B = 2 C = 3 */
/* yes */

?- (A, 2, C) = (1, B, 3).
/* A = 1 B = 2 C = 3 */
/* yes */
```

- リストのユニフィケーションもタプルと同様に動作する。

```prolog
?- [1, 2, 3] = [X, Y, Z].
/* A = 1 B = 2 C = 3 */
/* yes */

?- [2, 2, 3] = [X, X, Z].
/* X = 2 Z = 3 */
/* yes */

/* ユニフィケーションに失敗する例 */
?- [1, 2, 3] = [X, X, Z].
/* no */
```

- リストは`[Head|Tail]`という構文で分割することができる。`Head`にはリストの先頭要素、`Tail`には先頭を除いたリストがバインドされる。
  + この構文は空リストとはユニファイしないが、要素が1つのリストとはユニファイする(`Tail`には空リストが入る)。

```prolog
?- [a, b, c] = [Head|Tail].
/* Head = a, Tail = [b, c] */
/* yes */

?- [] = [Head|Tail].
/* no */
```

- さらに複雑なユニフィケーションも可能。
  + アンダースコアはワイルドカードとして機能し、何とでもユニファイするが、その値は無視することを意味する。

```prolog
/* 先頭要素がaなら、aを除いたリストをさらに先頭と残りのリストに分割 */
?- [a, b, c] = [a|[Head|Tail]].
/* Head = b, Tail = [c] */
/* yes */

/* 3番目の要素を取り出す */
?- [a, b, c, d, e] = [_, _|[Head|_]].
/* Head = c */
/* yes */
```

#### リストと数値計算
[リストの要素数の数え上げ･合計･平均の計算を行うルール](example/prolog/list_math.pl)

- `count`はリストの要素数を数える。`count(What, [1])`のように用いる(`What`に結果がユニファイされる)。このルールは以下のように構成されている。
  + 1つ目の節は｢空リストの要素数は0である｣ことを表す。
  + 2つ目の節は｢リストの要素数はTail部の要素数に1を加えたものである｣ことを表す。
- `count(What, [1])`という質問をした時の推論の流れは次のようになる。
  1. リストは空でないので、1つ目の節とはマッチしない。そこで、2つ目の節のゴールを満足させることを考える。ユニフィケーションの結果、`What`は`Count`に、`Head`は1に、`Tail`は`[]`にバインドされる。
  2. 最初のゴールは`count(TailCount, [])`である。これは`count`の1つ目の節とマッチするので、`TailCount`には0がバインドされる。
  3. 2つ目のゴール`Count is TailCount + 1`を評価することで`Count`は`0 + 1`、すなわち1にバインドされる。
- `sum`はリストの各要素の合計を求める。
  + 1つ目の節は｢空リストの合計は0である｣ことを表す。
  + 2つ目の節は｢リストの要素の合計は、リストの先頭要素と、Tail部の要素の合計を足し合わせたものである｣ことを表す。
- `average`は`sum`と`count`を組み合わせてリストの各要素の平均を求める。

#### ルールを両方向に使う
- `append(List1, List2, List3)`というルールは、`List3`が`List1`と`List2`の連結であるときに真となる。このルールは様々な使い方ができる強力なルールである。

```prolog
/* 述語として */
?- append([oil], [water], [oil, water]). /* yes */
?- append([oil], [water], [oil, slick]). /* no */

/* 連結されたリストを作る */
?- append([tiny], [bubbles], What).
/* What = [tiny, bubbles] */
/* yes */

/* リストの差分をとる */
?- append([dessert_topping], Who, [dessert_topping, floor_wax]).
/* What = [floor_wax] */
/* yes */

/* リストの分割方法を洗い出す */
?- append(One, Two, [apples, oranges, bananas]).
/* One = [], Two = [apples, oranges, bananas] ? */ a
/* ...(全ての分割方法が表示される) */
/* no */
```

- `append`ルールは次のように実現されている。
  + 1つ目の節は、｢空リストに別のリストを連結した結果はそのリスト自体である｣ことを表す。
  + 2つ目の節は、｢`List1`と`List3`のHeadが同じで、さらに`List1`のTailに`List2`を連結すると`List3`のTailに等しいなら、`List1`と`List2`を連結すると`List3`になる｣ことを表す。

```prolog
append([], List, List).
append([Head|Tail1], List2, [Head|Tail3]) :-
  append(Tail1, List2, Tail3).
```

### 4.4 3日目: ラスベガスをぶっとばせ
パズルを解くことは、制約の中で正しい手順を見つけるということであり、これはPrologの得意分野である。

#### 数独を解く
[4×4の数独を解くPrologプログラム](example/prolog/sudoku.pl)

#### 8クイーン問題
[8クイーン問題を解くPrologプログラム](example/prolog/eight_queens.pl)

### 4.5 Prologのまとめ
#### 長所
- 広範な問題(スケジューリングからパズルソルバーまで)に利用できる。要件の厳しい問題を解けるので存在価値は高い
- 応用範囲
  + 自然言語処理
  + ゲーム
  + セマンティックWeb
  + 人工知能
  + スケジューリング

#### 短所
- 論理プログラミングという狭い分野でしか能力を発揮できない。つまり、汎用言語ではない。
- 計算の戦略の性質上、計算量が多くなる。データセットが大規模になると扱うのが難しい。
- 再帰を多く用いるため、わずかなデータ量を超えるだけで動かなくなってしまうプログラムを書きがち。

***

[前へ](c3.md) /
[全体目次へ戻る](index.md) /
[次へ](c5.md)
