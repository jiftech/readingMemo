# 7つの言語 7つの世界 第4章
[全体目次へ戻る](index.md)

## 4章 Prolog
Prologは **宣言型言語** であり、命令型言語であるIoやRubyとは著しく異なる側面を持つ。命令型言語では、目的を達成するための方法をコンピュータに指示していくが、Prologのような宣言型言語では、事前に｢事実｣と｢ルール｣を記述しておき、コンピュータに質問をし、推論をさせるというアプローチで問題を解決する。

> 言ってみれば、(自分でケーキを焼く代わりに)おいしいケーキ屋さんに行くようなものだ。食べたいケーキの特徴を記述すると、与えられたルールに基づいて、ケーキ屋さんが材料を選び、ケーキを焼いてくれる。

Prologを人物に例えれば『レインマン』に登場する｢レイモンド｣である。Prologに対しても、レイモンドに対しても。｢なぜ分かったのか｣と｢なぜ分からないのか｣という疑問を、同じくらいの割合で抱くことになる。正しい方法で質問をしなければ、素晴らしい答えは得られない。

### 4.1 Prologについて
- Alain ColmerauerとPhillipe Rousselによって1972年に開発された論理プログラミング言語
- SQLと同様にデータベースを扱う
- Prologが扱うデータは論理ルールと関係からなる。
- SQLと同様、データを表現する部分とデータに質問する部分に分けられる。
- Prologの構成要素は以下の3つである。
  + 事実: 特定の世界についての基本的な表明(○○は××である など)
  + ルール: 世界の事実に関する推論(○○が××であれば、その○○は△△である など)
  + 質問: その世界に関する質問(○○は△△か? など)
- 事実とルールが｢知識ベース｣を構成する。Prologコンパイラは、質問が効率的に処理できる形に知識ベースをコンパイルする。

### 4.2 1日目: 素晴らしいドライバー
- Prologにはいくつもの方言がある。以下のコード例はGNU Prolog(gprolog)を使う場合のものである

#### 基本事実
- Prologでは、小文字で始まる単語は **アトム** 、大文字またはアンダースコアで始まる単語は **変数** として区別される。
  + 変数の値は変更できるが、アトムは変更できない
- Prologでの問題解決手順
  1. 知識ベース(事実とルールの組み合わせ)をファイルに記述(拡張子は`.pl`)
  2. 知識ベースをPrologインタプリタで読み込む
  3. Prologに質問をする
- [簡単な知識ベースの例](example/prolog/friends.pl)
  + `likes(a, b)`は｢a は b が好きだ｣という事実を表す
  + `friend(X, Y)`は｢X と Y が同一でなく、さらに両方が同じものが好きなら、X と Y は友達である｣というルールを表している
- 知識ベースを読み込むには、インタプリタで`['friends.pl'].`のように入力する。
  + ファイルが正しく読みこまれた場合、Prologは`yes`を返す。
- Prologに対する最も簡単な質問の例

```prolog
?- likes(wallace, sheep).
/* no */

?- likes(grommit, cheese).
/* yes */
```

#### 基本的な推論と変数
- `friend`ルール再考

```prolog
friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).
```

- `:-`の右側のコンマで区切られた各部分を **サブゴール** という。与えられた入力を事実に照らし、全てのサブゴールが満たされる場合にPrologは`yes`を返す。
  + 1番目のサブゴールにおいて、`\+`は論理否定を表すので、これは｢XとYが等しくない｣という意味
  + 2番目と3番目のサブゴールを合わせると｢XはZが好きで、かつYもZが好きである｣という意味。

- Prologの推論の流れ

```prolog
?- friend(wendolene, grommit).
/* no */
```

- 上記のような質問をしたとき、Prologは次の2つの可能性を試してみる
  + `wendolene`, `grommit`, `cheese`
  + `wendolene`, `grommit`, `sheep`
- 結局どちらも2番目と3番目のゴールを同時に満たすことはないので、Prologは`no`を返す。

- `friend`ルールはパラメータを2つ取るので`friend/2`と呼ぶ。


#### 穴埋め問題
- 質問の中に変数を指定することで、｢質問に対して考えられる全ての答えを見つける｣こともできる。
- 例) [食べ物の種類と味を表す知識ベース](example/prolog/food.pl)
  + `food_flavor(X, Y)`は、食べ物XがZという種類でZの味がYであるとき、Xの味はYであるというルール。
- この知識ベースに対する質問の例
```prolog
?- food_type(What, meat).
/* What = spam ? */ ;
/* What = sausage ? */ ;
/* no */
```
- 上の例では、Prologに｢`meat`であるような食べ物を見つけよ｣と尋ねている。Prologは1つ目の答え(`spam`)を返す。ここで`;`を入力すると、Prologは別の答えを探し、`sausage`を見つける。さらに`;`を入力すると、Prologはまた別の答えを探すが、見つからないので`no`を返す。
  + Prologは1つの答えを見つけたときに該当する値がもう存在しないことを(推論せずに)検出した場合答えと同時に`yes`を返す。
  + 一方、｢推論の結果｣、該当する値がもう存在しないと分かった場合は`no`を返す。
- 別の質問
```prolog
?- food_flavor(What, savory).
/* What = velveeta ? */ ;
/* What = spam ? */ ;
/* What = sausage ? */ ;
/* no */
```
- この例では、｢味が`savory`(塩辛い)な食べ物を全て見つけよ｣とPrologに命令している。Prologは食べ物、種類、味の全ての組み合わせを調べることで答えを導き出す。

##### 地図の塗り分け
- [米国南東部の州の地図を塗り分けるための知識ベース](example/prolog/map.pl)
- この知識ベースに対し次のように質問するだけで、Prologは適切な塗り分け方法を導き出してくれる。
```prolog
?- coloring(Alabama, Mississippi, Georgia, Tennessee, Florida).
```
- 1つの組み合わせが得られた後、全ての組み合わせを知るためには`a`を入力すれば良い。
- このように、Prologでは問題を解くためのアルゴリズムを記述するのではなく、｢事実を記述して、コンピュータに推論させる｣というアプローチで問題を解く。


***

[前へ](c3.md) /
[全体目次へ戻る](index.md) /
[次へ](c5.md)
