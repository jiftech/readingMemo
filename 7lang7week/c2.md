# 7つの言語 7つの世界 第2章
[全体目次へ戻る](index.md)

## 第2章 Ruby
Rubyを有名人に喩えると「メリー・ポピンズ」。
> 時々クセのある動作をするが、常に美しく、多少謎めいたところもあり、そして何より魔法のような力を秘めている。

Rubyの作者Matzの関心事は **プログラマ** の生産効率の最適化

## 2.1 簡単な歴史
- Rubyはスクリプト言語に属す
- インタプリタ方式…コンパイルされない
- オブジェクト指向…カプセル化･クラスによる継承･ポリモフィズム
- 動的型付け…型は実行時に決まる

一般にこのような戦略を取る言語は柔軟性と実行時の安全性のバランスをとるのが難しい

## 2.2 1日目
会話形式でRubyとやりとりしてみて、Rubyがどんなプログラミングモデルを採用し、型をどのように扱うのかを知ることから始める

### Rubyをコンソールから使う
- `irb`コマンドでRubyの対話型コンソールが起動する。
- 何か実行すると必ず値が返ってくる。戻り値がない場合`nil`が返る。
- 2種類の文字列がある
  + ｢' '｣で囲んだ文字列はそのまま解釈される
  + ｢" "｣で囲んだ文字列は評価される
    * `#{hoge}`で文字列の中に`hoge`の中身を埋め込める。下の例参照

```ruby
language = 'Ruby'
# => "Ruby"
puts "hello, #{language}"
# hello, Ruby
# => nil
```

- 疑問:上のコードで変数を宣言していないとあるが`language`は変数ではないの?

### プログラミングモデル
- Rubyは **純粋なオブジェクト指向言語** 。数値でさえもオブジェクト(`Fixnum`クラス)であり、メソッドを持つ
- `methods`メソッドは、そのオブジェクトが持つ全てのメソッドを配列で返す。

### 判定
- Rubyの条件式の結果は`TrueClass`クラスの`true`か`FalseClass`クラスの`false`で表される。これらも第一級オブジェクト
- Rubyには、ブロック形式の条件文の他に1行形式の条件文がある。
  + 例: `puts 'This appears to be true.' if x == 4`(xが4なら文が表示される)
  + これはブロック形式では以下のようになる。カッコは使わず終了は`end`で表す。

```ruby
if x == 4
  puts 'This appears to be true.'
end
```

- Rubyでは、`if`だけでなく`unless`が使える。`if`の逆。
  + 例: `puts 'This appears to be false.' unless x == 4`
- `while`も1行形式で書ける。もちろんブロック形式もある。
  + 例: `x = x + 1 while x < 10`
- `until`という繰り返し文もある。`while`の逆で、条件式が満たされたら終了。
  + 例: `x = x - 1 until x == 1`
- Cなどと違い、`nil`や`false`以外のものはすべて(0でさえも)`true`と評価される
- 論理演算子はCやJavaと同様の`&&` `||`と、同じ意味を持つ`and` `or`がある
  + さらに短絡評価をしない`&` `|` がある(いつ使うのかは謎)

### ダックタイピング
- Rubyは強く型付けされている。
- 型チェックはコンパイル時ではなく実行時に行う。これを **動的型付け** という。
  + `def`によって型エラーとなるような処理を関数として定義しても、その時点では実行されないのでエラーは起きない。その関数を呼び出したとき、初めてエラーが出る
- 複数のオブジェクトが同じ名前のメソッドを持っているのであれば、それらのオブジェクトの基盤となる型が違っていても、同じようにメソッドを呼び出せる。これを **ダックタイピング** といい、動的型付け言語で純粋なオブジェクト指向設計を行う際に重要な概念である。
  + 例えば、`push`と`pop`という2つのメソッドを持ったオブジェクトはスタックとして扱える。

例: ループの中で異なる型のオブジェクトに対し`to_i`を呼び出し整数に変換

```ruby
i = 0
# => 0
a = ['100', 100.0]
# => [...]
while i < 2
  puts a[i].to_i
  i = i + 1
end
# 100
# 100
```

## 2日目
オブジェクト、コレクション、クラスといった基本構成ブロックやコードブロックの基礎について

### 関数の定義
- 関数を定義するためにクラスを構築する必要はなく、トップレベルに関数を定義できる。
- 明示的に戻り値を指定しない場合、関数は最後に実行された式の値を返す。
- Rubyでは関数もオブジェクトである。

```ruby
def tell_the_truth
  true
end
```

### 配列
- Rubyの配列は`Array`クラスのオブジェクトである。
- 未定義の配列要素にアクセスすると`nil`が返る。
- マイナスの添字`[-n]`は **最後から** n番目の要素を返すシンタックスシュガーである。
- 添字に`[m..n]`のように範囲を指定できる。`m..n`はmからnまでの値の範囲を表す`Range`クラスのオブジェクトである
- `[]` や `[]=`は配列の要素にアクセスするためのシンタックスシュガーである。
  + `array = []`で空の配列arrayが作成できる
  + `array[n]`でn番目の要素を得る
  + `array[n] = ...`はn番目の要素を変更する
- 1つの配列に異なる型の要素を格納できる。
- 配列に配列を格納すれば多次元配列となる。Javaなどと同じようにアクセスできる。
- `push`や`pop`メソッドなどが定義されているので、配列を様々なデータ構造のように使える。

### ハッシュ
キーと値の組を格納するコレクション。

- `key => value`のペアを並べて中括弧で囲む。
  + 例: `numbers = { 1 => 'one', 2 => 'two'}`
- `:` で始まる識別子は｢シンボル｣という。 **同じシンボルはどこにあっても同じオブジェクト。** (同じ値を持つ文字列が同じオブジェクトであるとは限らない)

```ruby
stuff = {:array => [1, 2, 3], :string => 'Hi, mom!'}
stuff[:string]
# => "Hi, mom!"
```

- Rubyで名前付き引数のような機能を実現するために利用される。

```ruby
def tell_the_truth(options = {})
  if options[:profession] == :lawyer
    'it could be believed that this is almost certainly not false.'
  else
    true
  end
end

tell_the_truth
# => true
tell_the_truth :profession => :lawyer
# => it could be なんたらかんたら
```

### コードブロックとyield
コードブロックとは、中括弧(複数行の場合`do`~`end`)で囲まれたコードのまとまりで、名前の無い関数である。

- `Fixnum`クラスの`times`メソッドは、渡された処理をその値の回数分繰り返す。

```ruby
3.times { puts 'hiya there, kiddo' }
# hiya there, kiddo
# hiya there, kiddo
# hiya there, kiddo
```
- コードブロックには引数を指定できる。コレクションの各要素について処理を行う例。

```ruby
animals = ['hoge', 'fuga', 'foo', 'bar']
animals.each {|a| puts a}
# hoge
# fuga
# foo
# bar
```

- 関数内で`yield`を用いるとそこで渡されたコードブロックを実行する。`yield`が含まれる関数は、明示されていなくてもコードブロックを引数にとる。
- 関数の仮引数の先頭に`&`をつけるとコードブロックを引数として受け取る、という意味になる。

```ruby
def call_block(&block)
  block.call
end

def pass_block(&block)
  call_block(&block)
end

pass_block {puts 'Hello, block'}
# => Hello, block
```

Rubyでは、新たな制御構造を定義するためにコードブロックを用いる。

#### ファイルからRubyを実行する
スクリプトを｢hoge.rb｣という名前のファイルに保存して、コマンド`$ ruby hoge.rb`で実行できる。

### クラスの定義
#### Rubyのクラス階層
- Rubyのクラスは1つの親からしか継承できない。
- `Fixnum`クラスは、順番に`Integer`,`Numeric`,`Object`,`BasicObject`といったクラスから継承している。
  + また、`Fixnum`の｢クラス｣自体が`Class`クラスのインスタンスであり、これは`Module`,`Object`,`BasicObject`から継承している。
- 全てのクラスの共通の祖先は`BasicObject`である。

#### 木のクラスの実装
[Treeクラスの実装(tree.rb)](example/tree.rb)
- Rubyの慣例･規則:
  + 慣例: クラス名は大文字から始め、キャメルケースを使う。
  + 規則: インスタンス変数は`@`、クラス変数は`@@`を先頭につける。
  + 慣例: インスタンス変数やメソッドの名前は小文字から始め、区切りに`_`を使う
  + 規則: 定数は大文字で始める(全部大文字にすることが多い)。
  + 慣例: 判定用メソッド(関数)には疑問符`?`をつける。
- `initialize`メソッドはコンストラクタである。
- `attr`系のメソッドはインスタンス変数を定義する。いくつかの種類がある。
  + `attr`はインスタンス変数とその変数のgetterを定義する
  + `attr_accessor`はインスタンス変数とその変数のgetterとsetterを定義する

### Mixinを書く
- 多重継承の問題を解決するために
  + Javaではインタフェースを使う
  + Rubyでは *モジュール* を使う
- モジュールとは、関数と定数の集まりである。クラスに混ぜ込む

[ToFileモジュールの定義と利用例](example/to_file.rb)
- `ToFile`モジュールの`to_f`メソッドは、`filename`メソッドが提供する名前のファイルに`to_s`メソッドの出力を書き出す。
  + モジュールで利用されるメソッドはクラスの方で実装しておく必要がある。この場合`to_s`を`Person`クラスに実装しておく。
- `Person`クラスに`ToFile`モジュールをincludeするだけで、ファイルに書き出す機能を追加(**mixin**)することができる。
  + `Person`にサブクラスを追加すると、各サブクラスは`Person`にmixinされた全ての機能を使うことができる。
- 単一継承でクラスの中核を定義し、そこにモジュールで機能を追加するプログラミングスタイルを *mixin* と呼ぶ。単一継承とmixinの組み合わせは優れた動作を実現する。

### モジュール、Enumerable、セット
- Rubyで最も重要なmixin...`Enumerable`と`Comparable`
  + `Enumerable`: 列挙可能なもの これをincludeするクラスでは`each`メソッドを実装する必要がある
  + `Comparable`: 比較可能なもの これをincludeするクラスでは`<=>`メソッドを実装する。
    * これは`a <=> b`のように使い、aがbより｢小さい｣｢大きい｣｢等しい｣とき、それぞれ｢-1｣｢1｣｢0｣を返すように定義する。
- この2つのモジュールをmixinするだけで、コレクション操作のための多くのメソッドが使えるようになる。
  + `sort`: コレクションをソート
  + `any?`: コレクションのいずれかの要素が指定された条件に一致するとき`true`
  + `all?`: コレクションの全ての要素が指定された条件に一致するとき`true`
  + `collect/map`: コレクションの各要素に関数を適用し、その結果から配列を生成
  + `select/find_all`: コレクション内の、条件に一致する全要素をまとめた配列を生成
  + `inject`: コレクションの各要素を積算していく。初期値となる引数と、2引数関数を表すコードブロックを渡す。

```ruby
a.inject(0) do |sum, i|
  puts "sum: #{sum} i: #{i} sum + i: #{sum + i}"
  sum + i
end
# sum: 0 i: 5 sum + i: 5
# sum: 5 i: 3 sum + i: 8
# sum: 8 i: 4 sum + i: 12
# sum: 12 i: 1 sum + i: 13
# => 13
```

### セルフスタディ 2日目
- コードブロックを使わずにファイルにアクセスする場合、ファイルを`close`するコードを書く必要がある。コードブロックを使えばその必要はない
- ハッシュを配列に変換する
  + キーの配列は`h.keys`
  + 値の配列は`h.values`
  + キーと値の組の配列をまとめた配列(配列の配列)は`h.to_a`でok
- 配列をハッシュに変換する
  + 基本: `Hash[k1, v1, k2, v2, ...]` → `{k1 => v1, k2 => v2, ...}`
  + `a = [k1, v1, k2, v2, ...]`があるとき: `Hash[\*a]`
    * `[\*a]`は配列aの全要素を代入するという意味
  + `a = [[k1, v1], [k2, v2], ...]`があるとき: `Hash[\*a.flatten]`
    * `flatten`は多重配列を分解して全要素を1重の配列に格納する(平坦化)
  + ` k = [k1, k2, ...]`と`v = [v1, v2, ...]`があるとき: `Hash[\*([k,v].transpose).flatten]`
    * `[k,v].transpose`で｢キーと値の組の配列｣を要素とする配列を構成できる
- ハッシュに対する繰り返し処理: 配列と同様だが、種類が多い
  + `each`はキーと値の両方をコードブロックに渡す
  + `each_key`はキーのみ
  + `each_value`は値のみ
- Rubyの配列で実現可能なデータ構造:スタックの他にキューなど
- パス`path`のファイルから正規表現`rgx`にマッチする行だけを出力する簡易grep

```ruby
def grep(path,rgx)
  File.open(path) do |f|
    f.each_line {|line| puts line if line.match(rgx) != nil}
  end
end
```

***

[全体目次へ戻る](index.md) /
[次へ](c3.md)
