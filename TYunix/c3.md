# Unix独習への近道 第3章
[全体目次へ戻る](index.md)

## 3章 シンプルなコマンドをつないで複雑な処理を実行させる
### コマンドの種類
- 外部コマンド: `/bin`, `/usr/bin`などにある、実行可能ファイルの形式で提供されたコマンド
- 内部コマンド: シェル内部で処理されるコマンド
  + 新しいプロセスを起動しないので、`ps`で確認することはできない
  + `type`コマンドで判別することができる
- エイリアス: `alias`コマンドで設定できる、コマンド+引数への別名
  + 書式: `alias [name] = '[command] [options...]'`
- 関数: 複数の処理をまとめて、1つのコマンドであるかのように呼び出せる
- 変数宣言`declare`: シェル変数の型やスコープを指定する必要がある場合に用いる
  + `-i`: 整数
  + `-a`: 配列
  + `-f`: 関数
  + `-r`: 読み取り専用
  + `-x`: 環境変数
- `unset`: 定義した変数や関数を削除する

### リダイレクトとパイプ
- procディレクトリ内に、リダイレクトやパイプの動作原理を表したCプログラムがある

- リダイレクトとパイプ(基本)

| 書式           | 実行内容                           |
|:-------------- |:---------------------------------- |
| `cmd1 | cmd2 ` | `cmd1`の出力を`cmd2`の入力につなぐ |
| `> file`       | 標準出力を`file`に変更             |
| `< file`       | 標準入力を`file`に変更             |
| `>> file`      | 標準出力を`file`に追記             |

- リダイレクトとパイプ(発展)

| 書式      | 実行内容                                                 |
|:--------- |:-------------------------------------------------------- |
| `n> file` | n番のファイル記述子の出力を`file`につなぐ                |
| `n< file` | n番のファイル記述子の入力を`file`につなぐ                |
| `n>&m`    | n番のファイル記述子の出力を、m番のファイル記述子につなぐ |
| `n<&m`    | n番のファイル記述子の入力を、m番のファイル記述子につなぐ |
| `&> file` | 標準出力と標準エラー出力の両方を`file`に出力             |
| `>&-`     | 標準入力をclose                                          |
| `<%-`     | 標準出力をclose                                          |
| `n>&-`    | n番の出力ファイル記述子をclose                           |
| `n<&-`    | n番の入力ファイル記述子をclose                           |

```sh
# 標準出力と標準エラー出力の両方を捨てる
$ ls > /dev/null 2>&1
$ ls &> /dev/null

# 標準出力と標準エラー出力を別々のファイルにリダイレクト
$ ls > normal.txt 2> error.txt
```

- ヒアドキュメント`<< [認識用文字列]`: 指定した文字列(識別用文字列)が現れるまでのすべての入力を、データとしてリダイレクトする
- ヒアストリング`<<< [$var]`: 変数`$var`の内容をリダイレクトする


### シェルスクリプト
#### 変数
- シェル変数: シェル内部で使う変数。シェルの動作オプションとして用いることも多い
  + 変数定義の書式: `[変数名]=[値]` スペースで区切って複数の変数を1行で定義することもできる
  + 変数参照の書式: `$[変数名]` 変数名を`{}`で囲むことで、変数の内容と他の文字列との結合を簡単に実現できる
  + `set`コマンドを引数なしで実行すると、定義されている全ての変数・関数の一覧が表示される

```sh
$ serifu="Oishii"
# 変数serifuの中身に"_pyon"を結合
$ echo ${serifu}_pyon
Oishii_pyon
```

- 環境変数は、シェル変数のうち子プロセスにも継承されるものをいう
  + `export`コマンドで任意のシェル変数を環境変数にすることができる
  + 設定されている環境変数は`printenv`コマンドで確認できる

#### 算術演算
- `expr`コマンドで数式を評価できる(ただし、シェルが解釈する特殊文字はエスケープする必要あり)
- 算術展開構文 `$((...))` を使えば、エスケープなしで数式を評価できる
  + 変数は`$`をつけなくても参照できる

#### 制御構造
- シェルにおける条件判定の基準は、コマンドの終了ステータスである
  + `0`が成功(`true`)、それ以外なら失敗(`false`)
  + 直前のコマンドの終了ステータスは`$?`で取得できる

- `for`: リスト(スペース区切りの要素列)の要素1つ1つに対し処理を繰り返す
  + `in list`を省略すると、コマンドライン引数のリストに対する繰り返しとなる

```sh
# 書式
for var [in list]
do
  処理
done

# seqコマンドは指定した範囲の数列を返す
# $(...)は括弧内のコマンドを実行し、その出力を展開する
for i in $(seq 3 8)
  do echo $i
done

# C言語風の記法もある
for ((i=3; i<9; i++)); do
  echo $i
done

# コマンドライン引数を添え字とともに出力
# $#でコマンドライン引数の数を取得
n=$#
for ((i=0; i<n; i++)); do
  echo $i $1
  shift
done
```

- `while`/`until`: 条件を満たしている(満たしていない)間繰り返す

```sh
# 書式
while 条件
do
  処理
done
```

- `if`: 条件分岐。条件はコマンドの終了ステータスで判定する
  + `true`や`false`は一定の終了ステータスで終了するコマンド
  + `test`コマンドは、条件式を評価して真なら正常終了・偽なら異常終了する。専ら`if`の条件部に利用する
  + 条件式は`[ ... ]`という記法もできる。ここで`[`は`test`と同じ働きをするコマンドである(ただし、最後に`]`をつける必要がある)
    * 括弧の後にスペースが必要であることに注意
  + 数値の比較を行う場合は`((...))`記法を使うこともできる。記号の比較演算子が使える

```sh
# 書式
if 条件; then
  処理
elif 条件; then
  処理
else
  処理
fi
```

- 数あてゲーム
  + `read`コマンドは、入力を指定した名前の変数に代入する
    * `-p`をつけると、プロンプトメッセージを指定できる
  + `echo -n`は、出力の後の改行を抑止
  + 文字列をシングルクオートで囲むとすべての文字がエスケープされる。またダブルクオートで囲むとシェルが解釈する文字以外がエスケープされる

```sh
#!/bin/bash
echo '[[数あてゲーム]]'
thenumber=$(($RANDOM % 100))
numtry=1

read -p 'guess the number(0 - 99)!: ' ans
until (( ans == thenumber )); do
  if (( ans > thenumber )); then
    echo 'too large'
  else
    echo 'too small'
  fi
  echo -n "round $((++numtry)) "
  read -p 'guess(0-99).: ' ans
done
echo "you made a hit in ${numtry} times."
```

- ある条件においては「何もしない」場合は`:`コマンドを利用できる。これは何もせず成功する"nullコマンド"である

#### 論理演算子と複数コマンドの連続実行
- 論理演算子`&&`/`||`は短絡評価を行うので、「1つ目のコマンドの結果次第で2つ目のコマンドを実行するか決める」ような場合に活用できる

```sh
# 条件部が成功(true)なら"true"、失敗(false)なら"false"と表示する
# 条件部が失敗のとき、"[ ... ] && echo 'true'"全体が失敗となるので、"echo 'false'"が実行される
$ [ true ] && echo 'true' || echo 'false'
```

***

[前へ](c2.md) /
[全体目次へ戻る](index.md) /
[次へ](c4.md)
