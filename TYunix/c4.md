# Unix独習への近道 第4章
[全体目次へ戻る](index.md)

## 4章 ツール開発や自動化に応用できる文字列操作のノウハウ
### 簡単なテキスト処理(表示・並べ替え・結合・切り出し)
- `head`/`tail`: 入力の先頭/末尾を指定行数だけ出力する
  + `-n [num]`で行数を指定(デフォルトは10)
  + `head`の場合、行数に`-`をつけると末尾n行を削除する
  + `tail`の場合、行数に`+`をつけるとn行目以降を出力する

- `sort`: ソートする
  + デフォルトでは辞書順ソートになる。数値としてソートするには`-n`をつける(このとき、数値以外は先頭に来る)

```sh
# ヘッダ行が含まれている場合にヘッダ以外をソートするパターン
$ head -n +1 file; tail -n +2 file | sort

# エラーを考慮し、出力先をファイルにしたバージョン
$ (head -n +1 file && tail -n +2 file | sort) > file2
```

- `uniq`: 連続した重複行を取り除く

- `cat`: 複数のファイルを指定することで、ファイルの結合を行う
- `paste`: ファイルを横に結合する(`cat`は縦)

- `cut`: データからカラムを切り出す
  + `-f[カラム番号]`で切り出すカラムを指定する。カラム番号は左から・1始まり。コンマ区切りで複数指定できる
  + `-d`: 指定した文字を区切り文字にする。デフォルトではタブ
- `join`: 同じキーを持つ行を結合する
  + 各行はキーでソートされている必要がある

- `<(list)`という書法で`list`の内容を外側のコマンドの入力として扱うことができる
  + `list`はコマンドでもよく、その実行結果が入力となる。一時ファイルを作成しないので効率的

```sh
# 「f1から重複を除いたもの」とf2をキーで結合
$ join <(uniq f1) f2
```

- `comm`: 2つのファイルの各行を比較し、1番目のファイルのみ・2番めのファイルのみ・共通の行の3つに分類
  + 各行はソートされている必要がある

- `wc`: ファイルに含まれる行・単語・文字数を数える
- `nl`: 行番号をつけて表示する

- `rev`: 行ごとに文字を逆順に並び替える
- `tac`: 行を逆順に並び替える


### 文字置換・文字列演算・正規表現
- `tr`: 単純な文字の置き換えを行う
  + 書式: `tr [置き換え元文字集合] [置き換え先文字集合]`
  + 「第1引数のn番目の文字」を「第2引数のn番目の文字」に置き換える
  + `-c`: 置き換え元文字集合を、指定した文字集合の補集合にする
  + `-s`: 同じ文字が連続している箇所を1文字にまとめる
  + `-d`: 指定した文字集合に含まれる文字を削除する(第2引数は指定しない)

- bashの文字列演算: 変数内の文字列のうち、指定したglobパターンに一致する場所を削除したり置換したりする処理
  + 「文字列」に`null`を指定すれば削除と同じ動作になる

| 書式                       | 処理                                 |
|:-------------------------- |:------------------------------------ |
| `${変数#パターン}`         | 先頭から最短一致した部分を削除       |
| `${変数##パターン}`        | 先頭から最長一致した部分を削除       |
| `${変数%パターン}`         | 末尾から最短一致した部分を削除       |
| `${変数%%パターン}`        | 末尾から最長一致した部分を削除       |
| `${変数/パターン/文字列}`  | 最初の最長一致部分を「文字列」に置換 |
| `${変数//パターン/文字列}` | 全ての最長一致部分を「文字列」に置換 |

- `grep`: 正規表現に一致する行を抽出する
  + デフォルトでは基本正規表現しか使えない(`?`/`+`/`|`/グループ化が利用不可)。拡張正規表現を使うには`-E`オプションを指定する
  + `-F`: 正規表現を用いない検索。高速に処理可能
  + `-v`: 正規表現に一致「しない」行を抽出
  + `-i`: 大文字・小文字を区別しない
  + `-n`: 行番号を表示
  + `-A`/`-B`/`-C`: あとに数値を指定し、それぞれマッチした行の後ろ(After)/前(Before)/前後(マッチした行がCenter)をその行数だけ一緒に表示する  


### sed/awkによる本格的な文字列操作
- `sed`: テキストを行ごとに処理(フィルタリング)することに特化したツール
  + 書式: `sed '[パターン][コマンド] [対象ファイル]'`
  + パターンには正規表現(`/ ... /`)または行範囲(番号か正規表現をコンマ区切りで2つ並べる)を指定
    * `!`を末尾につけると、「パターンにマッチしなかった行」が処理対象になる
  + コマンドはパターンの直後に書く。処理は以下の通り
    * 複数指定する場合はセミコロンで区切る

| sedコマンド              | 処理                                                       |
|:------------------------ |:---------------------------------------------------------- |
| `s/[パターン]/[文字列]/` | パターンにマッチする部分を置換(行中の最初のマッチ部分のみ) |
| `s/.../.../g`            | 行中の全てのマッチ箇所を置換する                           |
| `i`                      | 大文字・小文字を区別しない                                 |
| `d`                      | パターンにマッチする部分を削除                             |
| `=`                      | 処理対象の行番号を表示                                     |

  + `-f`オプション: sedスクリプト(1行に対し複数の処理を行うために、sedコマンドを並べたファイル)の名前を指定して実行
  + `-e`オプション: 続く文字列がsedスクリプトに追加する命令であることを示す
    * スクリプトを用いずに複数の命令を繋げたいときに利用できる

  + `-n`オプション: 出力を抑止する
    * `p`コマンドがついた部分だけは出力される
  + `-i`オプション: 結果は出力されず、入力ファイルが直接編集される

```sh
# "or not to be"を含まない(!)行を削除(d)。処理対象の行番号を表示(=)
$ sed 'or not to be!d;=' hmlt.txt

# 1行目を削除
$ sed '1d' hmlt.txt
# 1～20行目を削除
$ sed '1,20d' hmlt.txt
# "FRANSISCO"を含む行から"BERNARDO"を含む行までを削除
$ sed '/FRANSISCO/,/BERNARDO/d' hmlt.txt

# 全ての"Hamlet"を"團十郎"に置換
$ sed 's/Hamlet/團十郎/g' hmlt.txt
# 1～20行目の"FRANSISCO"を"海老蔵"に置換
$ sed '1,20s/FRANSISCO/海老蔵/' hmlt.txt
```

- `awk`: データ処理に特化したスクリプト言語の1つ
  + 基本的には、指定した条件に合致する行に対して何らかの処理を行う、という動作
  + デフォルトで拡張正規表現が利用できる
  + `$[数値]`はn番目のフィールドを表す。`$0`は特殊で、行全体を表す

| awk関数                          | 処理                                                    |
|:-------------------------------- |:------------------------------------------------------- |
| `length`                         | 行の長さ                                                |
| `NF`                             | 「フィールド」(区切り文字で区切られた文字の並び)の数    |
| `NR`                             | 現在の行番号                                            |
| `print`                          | あとに指定したもの(文字列、変数)を出力(改行を入れる)    |
| `printf("[書式]",[変数]...)`     | 書式指定可能な`print`(明示的に書かないと改行を入れない) |
| `gsub(/[パターン]/, "[文字列]")` | パターンに一致する部分を指定文字列に置換                |


### awkスクリプト
- 基本書式: `[パターン] {[アクション]}`の連続。パターンに一致した行に対し、その後のアクションを実行
  + `BEGIN`パターンはデータ入力の開始前、`END`パターンは全データを読み込んだあとにマッチする特殊なパターンで、前処理・後処理を行うことができる
***

[前へ](c3.md) /
[全体目次へ戻る](index.md) /
[次へ](c5.md)
