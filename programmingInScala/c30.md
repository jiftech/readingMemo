# Scalaスケーラブルプログラミング 第30章
[全体目次へ戻る](index.md)

## 30章 オブジェクトの等価性
### Scalaにおける等価性
- Javaと異なり、Scalaの`==`メソッドは(`equals`と同様に)値の同値性をチェックする
  + Javaの`==`演算子のように参照の等価性をチェックするには`eq`メソッドを使う

### 等価メソッドの開発
- `equals`メソッドの実装は見かけよりも難しい
  + 落とし穴が多い!

- 落とし穴1: シグネチャの間違い
  + 引数の型はその型自身ではなく`Any`でなければならない
  + 間違えると、無意識のうちにオーバーロードしたことになってしまう
- 落とし穴2: `hashCode`に変更を加えずに`equals`だけを変更する
  + `o1 equals o2`ならば`o1.hashCode == o2.hashCode`でなければならない
    * これを守らないと`hashSet`などの動作がおかしくなる
  + `hashCode`の定義で利用できるフィールドは`equals`の定義で利用できるフィールドに限る
  + `##`メソッドは便利
    * タプルやコレクション型に対して`##`を呼ぶことで、全要素からハッシュコードを計算することができる
- 落とし穴3: ミュータブルフィールドによって`equals`を定義する
  + コレクションに入ったオブジェクトのフィールドを変更すると動作がおかしくなる
- 落とし穴4: `equals`が数学的な「同値関係」の規則を満たしていない
  + 反射律: `x == x`は常に`true`
  + 対称律: `x == y`は`y == x`が`true`のとき、かつそのときに限り`true`
  + 推移律: `x == y && y == z`が`true`のとき、`x == z`も`true`
  + 一貫性: 同じオブジェクトの組み合わせに対して結果が変化しない

- クラス階層をまたがった同値性のチェックにおいて同値関係の規則を満たすのは難しい
  + インスタンスの実行時型が異なる場合は常に`false`を返さなければならない
  + `canEqual(other: Any)`メソッドはレシーバと引数のオブジェクト間で等価性のチェックが可能かどうかを返すように定義する。ここでレシーバと引数の実行時型が一致することを確かめればよい

***

[前へ](c29.md) /
[全体目次へ戻る](index.md) /
[次へ](c31.md)
