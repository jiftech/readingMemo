# Scalaスケーラブルプログラミング 第20章
[全体目次へ戻る](index.md)

## 20章 抽象メンバー
- Scalaでは、メソッドだけではなくクラスのすべての種類のメンバーを定義のない｢抽象メンバー｣にできる
  + メソッド
  + 型メンバー
  + `val`フィールド、`var`フィールド

```scala
// すべての種類の抽象メンバーを持つトレイト
trait Abstract {
  type T
  def transform(x: T): T
  val initial: T
  var current: T
}
// Abstractトレイトの各抽象メンバーを実装するクラス
class Concrete extends Abstract {
  type T = String
  def transform(x: String) = x + x
  val initial = "hi"
  val current = initial
}
```

### 抽象型
- **抽象型** とは、定義が指定されていない型メンバー(`type`)である
  + 抽象クラスのことを指すわけではない
- `Concrete`クラスの`T`のような具象型メンバーは、型の｢別名｣を定義する手段と考えることができる
  + `Abstract`における`T`という型宣言は、`Concrete`の中では`Concrete`の実装時に`T`に定義された型に置き換えられる

### 抽象val
- 名前と型のみ定義された`val`。値はサブクラスで定義しなければならない
- 抽象`val`の実装は、`val`定義でなければならない。`var`や`def`はダメ
  + cf.) 抽象メソッドの実装は`def`でも`val`でも構わない

### 抽象var
- 抽象`var`もゲッターとセッターに展開される
  + ゲッターやセッターも抽象メソッドとなる

### 抽象valの初期化
- 抽象`val`を用いて、クラスにパラメーターを渡すことをシミュレートできる
  + トレイトにパラメーターを与えるようなこともできる
- 抽象メンバーを持つトレイト･抽象クラスに対し、生成時に抽象メンバーの定義を行うことで **無名クラス** のインスタンスを生成できる

```scala
trait RationalTrait {
  val numerArg: Int
  val denomArg: Int
}
// トレイトの抽象メンバーに定義を与えて無名クラスを生成
// new Rational(1, 2)というインスタンス生成に似ている
new RationalTrait {
  val numerArg = 1
  val denomArg = 2
}
```

- 通常のクラスの初期化では、クラスパラメーターに渡す式がクラスの初期化前に評価されるが、上記のようなサブクラスでの`val`の実装はスーパークラスが初期化された後に行われるという違いがある
  + スーパークラスの初期化時にサブクラスにおけるフィールド実装の内容が使えないという問題がある
- **事前初期化済みフィールド** を用いると、スーパークラスの初期化前にサブクラスのフィールド実装を初期化できる
  + まずサブクラスにおけるフィールドの定義を書き、その後ろに`with`に続けてトレイト･抽象クラス名を書く
  + 事前初期化済みフィールドは、オブジェクトや名前付きサブクラスの定義においても使える

```scala
// 事前初期化済みフィールド
new {
  val numerArg = 1
  val denomArg = 2
} with RationalTrait
```

- サブクラスの具象フィールドを **遅延評価`val`** にすることで、問題を回避することもできる
  + フィールドの定義において、名前の前に`lazy val`をつけるとそのフィールドは遅延評価`val`となり、そのフィールドに初めてアクセスしたタイミングで初期化されるようになる
  + 遅延評価`val`への2度目以降のアクセスでは、初回にアクセスしたときの評価結果が再利用される
- 遅延評価`val`のコード上の定義順序は実際の初期化順序に影響を与えない。初期化において副作用が起きない場合は、`val`の定義の順序を深く考えなくてよくなる
  + 変数の初期化で副作用を起こさない関数型オブジェクトに適している一方、命令形で書かれているコードには適していない

### 抽象型宣言の意味
-
***

[前へ](c19.md) /
[全体目次へ戻る](index.md) /
[次へ](c21.md)
