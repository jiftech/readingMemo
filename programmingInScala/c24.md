# Scalaスケーラブルプログラミング 第24章
[全体目次へ戻る](index.md)

## 24章 コレクションの探究
### ミュータブルなコレクションとイミュータブルなコレクション
- Scalaでは、ミュータブルなコレクションとイミュータブルなコレクションを系統的に区別している
  + `scala.collection.mutable`パッケージに含まれるミュータブルなコレクションでは、副作用として要素を変更･追加･削除できる
  + `scala.collection.immutable`パッケージに含まれるイミュータブルなコレクションは、変更できない。同じコレクションにいつアクセスしても、中の要素は変化していないことが保証されている
    * 要素の変更･追加･削除の結果は、これらの演算の返り値として得られる新しいコレクションである
- 何も指定しなければ、イミュータブルなコレクションが選択される
  + ミュータブルなコレクションをデフォルトにするには、`scala.collection.mutable`配下のコレクションをインポートする必要がある
- `scala.collection.generic`パッケージは、コレクションを組み立てるための基礎を含んでいる

### コレクションの一貫性
- あらゆるコレクションは、コレクションクラス名の後ろに要素を書く構文で生成できる
  + すべてのコレクションの`toString`メソッドも、このような形式の出力を生成する
```scala
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(1, 2, 3)
IndexedSeq(1.0, 2.0)
// コレクションの特定の実装についても同様
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)
```

- すべてのコレクションは`Traversable`トレイトが提供するAPIをサポートするが、それらのメソッドは(`Traversable`ではなく)自分自身のクラスのインスタンスを返す。
  + 例えば、`List.map`メソッドの返り値の型は`List`で、`Set.map`メソッドの返り値の型は`Set`である

### Traversableトレイト
- Scalaコレクション型階層の最上位に位置するトレイト。ただひとつの抽象メソッド`foreach`をもつ
  + 他のすべてのメソッドは`Traversable`から継承できる
```scala
// コレクションのすべての要素に対し、副作用を持つ関数fを適用する
// Uは任意の結果型だが、fの結果はすべて破棄される
def foreach[U](f: Elem => U)
```

- `Traversable`は多くの具象メソッドを定義している。具象メソッドは次のように分類できる
  + 加算･追加(`++`): 2つのTraversableを加える
  + マップ演算(`map`, `flatMap`, `collect`): 各要素に関数を適用して新しいコレクションを作る
  + 変換(`to***(変換先のコレクションクラス名)`): 別のコレクションに変換する
  + コピー演算(`copyToBuffer`, `copyToArray`): 要素をバッファや配列にコピーする
  + サイズ情報(`isEmpty`, `nonEmpty`, `size`, `hasDefiniteSize`): コレクションの要素数に関する情報を返す
    * `hasDefiniteSize`は、コレクションが確実に有限なら`true`を返すメソッド
  + 要素取得(`head(Option)`, `last(Option)`, `find`): コレクションの先頭や末尾などの要素を取得する
  + 部分コレクション取得(`take`, `drop`, `tail`, `filter`など): 添字の範囲や述語関数で規定された部分コレクションを返す
  + 分割(`splitAt`, `partition`, `groupBy`など): コレクションを複数の部分コレクションに分割する
  + 要素テスト(`exists`, `forall`, `count`): 指定条件によってコレクションの要素を検査する
  + 畳み込み(`foldLeft`, `foldRight`など): コレクションの要素に順に二項演算を適用していく
  + 型限定の畳み込み(`sum`, `product`, `min`, `max`): 特定の型のコレクションに対し定義された畳み込み
  + 文字列演算(`mkString`, `addString`, `stringPrefix`): コレクションを文字列に変換する
  + ビュー演算(`view`): ビュー(遅延評価されるコレクション)を生成する
- [`Traversable`のすべてのメソッド](collection/traversable.md)

### Iterableトレイト
- コレクション型階層の2番めに位置するトレイト。抽象メソッド`iterator`が定義されている
  + `iterator`はコレクションの要素を1つずつ返すオブジェクトを返すように実装する
  + `Iterable`における`foreach`の実装には`iterator`メソッドが利用されている
```scala
def foreach[U](f: Elem => U): Unit = {
  val it = iterator
  while(it.hasNext) f(it.next())
}
```

- `Iterable`にはイテレータを返すメソッドがほかに2つある
  + `grouped`メソッドは、指定された数ずつ要素を切り出して返すイテレータを生成する
  + `sliding`メソッドは、指定された数の要素を切り出す｢窓｣を、前から順にスライドして切り出した要素を返すイテレータを生成する
```scala
val xs = List(1, 2, 3, 4, 5)
val git = xs grouped 3
git.next() // => List(1, 2, 3)
git.next() // => List(4, 5)

val sit = xs sliding 3
sit.next() // => List(1, 2, 3)
sit.next() // => List(2, 3, 4)
sit.next() // => List(3, 4, 5)
```

- 他にも、イテレータが使えるときに限って効率的に実装できるメソッドを提供する
- [`Iterable`のすべてのメソッド](collection/iterable.md)

- `Iterable`の下に`Seq`, `Set`, `Map`の3つのトレイトがある。これらのトレイトはすべて`PartialFunction`トレイトを継承し、`apply`, `isDefinedAt`メソッドを実装している
  + `Seq.apply`は、添字で要素を参照するメソッドとして実装されている
  + `Set.apply`は、指定した要素が含まれているかを検査する
  + `Map.apply`は、指定したキーに対応する値を返す

#### TraversableとIterableの両方がある理由
- コレクション演算によっては、`iterator`による実装よりも`foreach`による実装のほうが簡単で効率がよい場合があるため

### シーケンストレイト
- `Seq`トレイトはシーケンス(長さがあり、0から始まる添字で要素の場所を指定できる`Iterable`)を表す
- `Seq`の演算は以下のように分類できる
  + 添字検索(`indexOf`, `indexOfSlice`, `indexWhere`など): 指定された値または条件を満たす要素の位置を返す
  + 加算･追加(`+:`, `:+`, `padTo`): シーケンスの先頭･末尾に要素を追加する
  + 更新(`updated`, `patch`): シーケンスの一部の要素を指定した値で置き換える
    * ミュータブルシーケンスには`update`メソッドもある。`updated`は新しいシーケンスを返すが、`update`は元のシーケンスを上書きする
    * `xs update(idx, x)`メソッドの略記法として、`xs(idx) = x`という構文が利用できる
  + ソート(`sorted`, `sortWith`, `sortBy`): 指定条件でシーケンスの要素を並べ替える
  + 反転(`reverse`など): 要素を逆順にしたシーケンスを生成する
  + 比較(`startsWith`, `contains`, `corresponds`など): あるシーケンスの一部を別のシーケンスと対応付けて比較し、条件を満たすか検査する
  + 集合演算(`intersect`, `diff`, `union`, `distinct`): シーケンスを集合とみなし、集合演算をおこなう

- [`Seq`のすべてのメソッド](collection/seq.md)

- `Seq`トレイトには`LinearSeq`と`IndexedSeq`の2つのサブトレイトがある。違いは個々の演算のパフォーマンスにある
  + `LinearSeq`では`head`,`tail`演算が高速に行える。主な実装に`List`,`Stream`がある
  + `IndexedSeq`では`apply`(添字によるアクセス)や`length`,`update`演算が効率的に行える。主な実装に`Array`,`ArrayBuffer`がある
  + `Vector`クラスでは、添字アクセスも`head`のような線形アクセスも一定時間で行える。どちらのアクセス方法もよく使うプログラムで効率的である

#### バッファ
- バッファは、効率的な要素の挿入･削除･末尾への要素追加をサポートする。
  + 末尾への要素追加には`+=`,`++=`メソッド、先頭への要素追加には`+=:`,`++=:`メソッドを使う
- [`Buffer`のすべてのメソッド](collection/buffer.md)
- バッファの実装には`ListBuffer`と`ArrayBuffer`の2つがあり、それぞれ`List`、`Array`への変換が高速に行える

### 集合
- `Set`は重複する要素を含まない｢集合｣を表す
- `Set`の演算は以下のように分類できる
  + 検査(`contains`, `apply`, `subsetOf`): 指定した要素が集合に含まれるかどうかを検査する
  + 追加(`+`, `++`): 指定した要素を追加した新しい集合を返す
  + 削除(`-`, `--`): 指定した要素を削除した新しい集合を返す
  + 集合演算(`intersect(&)`, `union(|)`, `diff(&~)`): 集合の積･和･差を求める
- ミュータブルな集合は、要素を追加･削除･更新するメソッドを持つ
  + ミュータブルな集合における要素の追加･削除は`+=`,`-=`のようなメソッドで行う。イミュータブルな集合での演算とは違い、コピーを行わないため効率的である
  + イミュータブルな集合は`+=`,`-=`メソッドを持たないが、`s += 4`を`s = s + 4`と解釈する仕組みがあるため、ミュータブル集合のものに似た演算を同じ形式で行うことができる
  + `val`に格納されたミュータブルコレクションは、`var`に格納されたイミュータブルコレクションに置き換え可能である

```scala
// sはイミュータブル集合
var s = Set(1, 2, 3)
// イミュータブル集合に"+="メソッドはないので、"s = s + 4"の呼び出しに置き換えられる
s += 4
s // => Set(1, 2, 3, 4)
```

```scala
import scala.collection.mutable.Set
// sはミュータブル集合
val s = Set(1, 2, 3)
// ミュータブル集合の"+="メソッドは、要素を追加し、その結果を返す
s += 4 // => Set(1, 2, 3, 4)
```

- [`Set`のすべてのメソッド](collection/set.md)

- ミュータブル集合のデフォルト実装はハッシュテーブルを利用する
- イミュータブル集合のデフォルト実装は、要素数によって変化する
  + 要素数が4個以下の場合、すべての要素をフィールドとして格納する単一のオブジェクトで表現される
    * 要素数に応じて`Set1`,`Set2`,...のようなクラスがある
  + 要素数がもっと多い場合、ハッシュトライとして実装される

### マップ
- `Map`は、キーと値の組を保持する`Iterable`である
- `Map`の演算は以下のように分類できる
  + 検索(`apply`, `get`, `getOrElse`, `contains`など): 指定したキーに対応する値を検索し、返す
  + 追加と更新(`+`, `++`, `updated`): 新しいキー･値の組を追加するか、既存の組を更新する
  + 削除(`-`, `--`): 指定したキー･値の組を削除する
  + 部分コレクション生成(`keys`, `values`など): キーだけ、または値だけを集めたコレクションを生成する
  + 変形(`filterKeys`, `mapValues`): キー･値の組に対し、キーによるフィルタリングや値に対するマップ演算を行い、新しいマップを生成する
- ミュータブルなマップは、ミュータブルな集合と同様に、キー･値の組を追加･削除･更新するメソッドを持つ
  + `getOrElseUpdate`というメソッドは、キーに対応する値があればそれを返すが、キーに対応する値が含まれていない場合はマップを更新する。値は更新を行う必要があるときに限り評価される(名前渡し)

- [`Map`のすべてのメソッド](collection/map.md)

### 具象イミュータブルコレクションクラス
- リスト(`List`): 有限のイミュータブルシーケンスで。先頭要素･先頭以外の要素からなるリストへのアクセスや、先頭への要素追加が定数時間で行える
- ストリーム(`Stream`): 要素が遅延評価されるので、無限の長さを持つことができる。要素の追加は`#::`という演算子で行う

```scala
def fibFrom(a: Int, b: Int): Stream[Int] = a #:: fibFrom(b, a + b)
val fibs = fibFrom(1, 1).take(7)  // => fibs: Stream(1, ?)
fibs.toList // => List(1, 1, 2, 3, 5, 8, 13)
```

- ベクター(`Vector`): リストとは異なり、先頭以外の要素も｢実質的に定数時間｣でアクセス･更新できる
  + ベクターは広くて浅い木構造で表現されており、要素数2^30個以下のベクターの要素選択は5回以下の配列選択で実現できる
  + `IndexedSeq`のデフォルト実装である

- 範囲(`Range`): 等間隔で並んだソート済みの整数シーケンス
  + 範囲を生成するには`to`または`until`メソッドを用いる。前者は終点を含む、後者は終点を含まない範囲を生成する。
  + 増分を指定するには`by`メソッドを用いる

```scala
1 to 3 // => Range(1, 2, 3)
1 until 3 // => Range(1, 2)
// 5から14まで、3つずつ増加する数列
5 to 14 by 3 // => Range(5, 8, 11, 14)
```

- ハッシュトライ(`HashMap`): イミュータブルな集合やマップのデフォルト実装で、効率的な検索･挿入･削除が行えるデータ構造
- 赤黒木(`TreeSet`): 順序付き集合･マップを効率的に実装できるデータ構造。`SortedSet`のデフォルト実装
- ビットセット(`BitSet`): ビット列を用いて、少数の整数からなる集合を表現する。含まれる整数の最大値が小さければ、演算は高速に行える

### 具象ミュータブルコレクションクラス
- 配列バッファ(`ArrayBuffer`): 配列バッファに対する演算は、配列と同じ速さで実行できる。配列バッファの末尾への要素追加は、平均して定数とみなせる時間で行える
- リストバッファ(`ListBuffer`): 配列バッファに似ているが、内部データ構造には連結リストを使っている
- 文字列ビルダー(`StringBuilder`): 文字列用のバッファクラス
- ミュータブルリスト(`MutableList`): 1本の連結リストと終端ノードを指すポインタからなる。これにより、要素追加が一定時間で行えるようになる。`mutable.LinearSeq`の標準実装
- 配列シーケンス(`ArraySeq`): 要素を`Array[AnyRef]`に格納する固定サイズのシーケンス
- 配列スタック(`ArrayStack`): 通常のミュータブルスタックよりも様々な演算が効率的に行えるスタック
- ハッシュテーブル(`HashSet`): ハッシュコードに基づき要素を配列に格納するデータ構造で、ミュータブル集合･マップのデフォルト実装
  + 必ず追加した順序で反復処理を行いたい場合は、連結ハッシュ集合(`LinkedHashSet`)を使う
- 弱参照ハッシュマップ(`WeakHashMap`): マップ以外からのキーへの参照がなくなると、そのキーとそれに対応する値が消えるマップ
- ビットセット(`BitSet`): イミュータブルなビットセットに似ているが、直接書き換え可能なので更新を効率的に行える

### 配列
- Scalaの配列は、Javaの配列と1対1で対応しているが、より多くの機能を持つ
  + ジェネリックにできる
  + `Seq[T]`が使えるすべての場所で`Array[T]`を使える(`Seq`のサブ型)
  + すべてのシーケンス演算が利用できる
- 配列が`Seq`として使われるとき、配列は暗黙的に`WrappedArray`クラスにラッピングされる。また、配列にシーケンス演算を追加するだけの(`Seq`に変換するわけではない)`ArrayOps`への変換も存在する
  + `WrappedArray`への変換と`ArrayOps`への変換がどちらも利用できる状況では、`ArrayOps`への変換が優先される
- ジェネリックな配列を作成するには、実行時に消去される型の情報を補う必要がある。型情報を補うためには、`ClassTag`型の暗黙のパラメーターを渡すようにすればよい

```scala
import scala.reflect.ClassTag
// ｢T型が実際にはどんな型なのか｣という情報を補うために、コンテキスト境界を用いてクラスタグを渡す
def evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for(i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
```

### 文字列
- Scalaでは文字列も`Seq`に変換でき、すべてのシーケンス演算を利用できる
  + `IndexedSeq`のサブクラス`WrappedString`への変換と、文字列にシーケンス演算を追加するだけの`StringOps`への変換が存在する

### 等価性
- 違う種類のコレクション同士は、たとえ含まれる要素が同じでも等しくない
  + 例えば、`List(1, 2, 3)`と`Set(1, 2, 3)`は等しくない
- 同じ種類のコレクション同士は、含まれる要素が同じ場合、等しい
  + ただし、シーケンスの場合は要素の順序も等しい場合のみ等しい
- ミュータブルかイミュータブルかということは、等価性の判断に影響を与えない
  + ミュータブルコレクションの場合、等価性検査を行った時点での要素のみを基準に等価性が判断される

### ビュー
- ビューは、コレクションを変換して新しいコレクションを返す演算(トランスフォーマー)を遅延的に実装している特殊なコレクションである
- コレクションを、それに対応するビューに変換するには`view`メソッドを使う。ビューを通常のコレクションに戻すには`force`メソッドを使う
  + `force`の結果型は`Seq`などの汎用コレクション型となる
- コレクションに対し変換処理を複数回適用するとき、無駄な中間生成物を作らないようにすることで効率が良くなる。そのためには、まず変換対象のコレクションをビューにし、ビューに対して変換を適用してから、最後にビューをもとのコレクションに戻せばよい
- 副作用を持つ演算をビューに適用するのは望ましくない。副作用はビューが`force`によってもとのコレクションに戻されるときに初めて実行されるため、プログラムの実行順序が分かりづらくなる

### イテレータ
- イテレータに対しても`Traversable`などに含まれる大半のメソッドと同様の機能が提供されている。しかし一度そのような演算を行うとそのイテレータは末尾を指したままとなり、再利用できない
  + 逆にいえば、イテレータはメソッド呼び出し後に同じイテレータにアクセスしない限り、コレクションと同様に動作する
- `Traversable`と`Iterator`の共通スーパートレイトとして`TraversableOnce`が定義されている。`TraversableOnce`からは`foreach`で要素を順に取り出せるが、その後のオブジェクトの状態は定義されない
  + `TraversableOnce`は、`Traversable`も`Iterator`も引数にとれるメソッドの引数型として使用されている

- [`Iterator`のすべてのメソッド](collection/iterator.md)

- バッファ付きイテレータ(`BufferedIterator`)は、`head`メソッドによって次の要素を先読みできるイテレータである

### 0からコレクションを作る
- コレクションクラスのコンパニオンオブジェクトには、対応するコレクションを生成するファクトリーメソッドが定義されている
  + すべてのコレクションで、指定した要素を含むコレクションを作る`apply`と、空のコレクションを作る`empty`が定義されている
  + シーケンスに対してはさらにいくつかのファクトリーメソッドが用意されている

- [シーケンスのファクトリーメソッド](collection/seqFactory.md)

### JavaコレクションとScalaコレクションの相互変換
- `JavaConversion`オブジェクトに主要なコレクション型の暗黙の型変換が定義されている
  + ミュータブルな`Buffer`,`Set`,`Map`はJavaの`List`,`Set`,`Map`と相互変換可能
  + `Seq`やイミュータブルな`Set`,`Map`はJavaの`List`,`Set`,`Map`に変換できるが、逆方向の変換はできない
    * イミュータブルなコレクションをJavaコレクションに変換した場合、変換後のコレクションを変更する操作を呼び出すと`UnsupportedOperationException`が投げられる

***

[前へ](c21.md) /
[全体目次へ戻る](index.md) /
[次へ](c25.md)
