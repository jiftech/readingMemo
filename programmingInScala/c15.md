# Scalaスケーラブルプログラミング 第15章
[全体目次へ戻る](index.md)

## 15章 ケースクラスとパターンマッチ
### ケースクラス
- クラスの定義に`case`修飾子をつけたクラスを **ケースクラス** と呼ぶ

```scala
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class BinOp(op: String, left: Expr, right: Expr) extends Expr
```

- ケースクラスには自動的にいくつかの機能が追加される
  + クラスと同じ名前のファクトリーメソッドが追加される
  + すべてのクラスパラメータは`val`フィールドとして扱われる
  + `toString`, `hashCode`, `equals`の自然な実装が追加される
    * `equals`はクラスの引数も含めて等価性を評価する
  + 一部の引数を変更した新しいオブジェクトを生成するのに便利な`copy`メソッドが追加される

- クラスをケースクラスとすることで、**パターンマッチで利用できるようになる**

```scala
// ファクトリーメソッド
val e = BinOp("+", Var("x"), Var("x"))
// クラスパラメータのフィールド化
e.op // => +
// toStringの自然な実装
e.toString // => BinOp(+, Var(x), Var(x))
// (hashCode,)equalsの自然な実装
e.left == e.right // => true
// copyメソッドの追加
e.copy(op = "-") // => BinOp(-, Var(x), Var(x))
```

### パターンマッチ
- パターンマッチ式は、ある式が特定のパターンに合致するときに指定した式を評価する、一種の関数である
  + `<マッチ対象の式> match { <選択肢> }`という形式
  + 選択肢は`case <パターン> => <パターンが合致するときに評価される式>`となる
- Javaの`switch`よりも多くの式をマッチ対象として使える。また、Javaのようなフォールスルーは起きない
- 合致するパターンが見つからない場合は例外が投げられる
  + 合致しないときに何もしないようにするには｢空のケース｣を書く必要がある

```scala
expr match {
  case Var(name) => println("variable")
  case BinOp(op, left, right) => println("binary operation")
  case _ => // do nothing
}

```

### パターンの種類
- ワイルドカードパターン: `_`で表され、あらゆるオブジェクトにマッチする。デフォルトケースとして用いる
  + オブジェクトの特に注目しない部分を無視するのにも`_`を使う

```scala
expr match {
  case BinOp(op, _, _) => println("binary operation" + op)
  case _ =>
}
```

- 定数パターン: 任意のリテラルで表され、マッチ対象がそれと等しい場合のみマッチする。`val`変数やシングルトンオブジェクトも定数として利用できる
  + **大文字から始まる** 識別子はすべて定数とみなされる
```scala
def desc(x: Any) = x match {
  case 5 => "five"
  case true => "truth"
  case "hello" => "hi!"
  case Nil => "the empty list"
  case _ "something else"
}
```

- 変数パターン: **小文字から始まる** 識別子で表される。任意のオブジェクトにマッチし、マッチしたオブジェクトと識別子を対応付ける
  + 小文字から始まる定数を定数パターンとみなすようにするには、それをバッククォートで囲む必要がある
```scala
expr match {
  case 0 => "zero"
  // exprが0でなければ"not zero: "のあとにexprの内容をつけた文字列が返る
  case somethingElse => "not zero: " + somethingElse
}
```

- コンストラクタパターン: ケースクラスのファクトリーメソッドと同様の形式で表され、オブジェクトの型と、クラスパラメータが全て一致する場合にマッチする。クラスパラメータの一致は再帰的にチェックされる
```scala
expr match {
  // exprがBinOp型で、第1引数が"+", 第3引数がNumber(0)である場合にマッチ
  // (第2引数は変数パターンなので任意)
  case BinOp("+", e, Number(0)) => println("e + 0")
  case _ =>
}
```

- シーケンスパターン: `List`や`Array`のようなシーケンスの中身の個数や特定位置の要素の条件を指定でき、その条件に一致する場合にマッチする
  + コンストラクタパターンに似ているが、指定できる要素数が任意である
  + パターンの最後の要素に`_*`を指定すると、任意長のシーケンスにマッチする
```scala
expr match {
  // 先頭が0で3要素のListにマッチ
  case List(0, _, _) => println("[0, ?, ?]")
  case List(1, 2, _*) => println("[1, 2, ...]")
  case _ =>
}
```

- タプルパターン: いくつかの要素をコンマで区切り、丸括弧で囲んだ形で表される。要素数とそれぞれの値が一致する場合にマッチする
```scala
def tupleMatch(expr: Any) = expr match {
  // 任意の3要素のタプルにマッチし、それぞれの中身を表示
  case (a, b, c) => println("matched " + a + b + c)
  case _ =>
}
```

- 型付きパターン: 変数パターンのあとに`: <型名>`の形式で型を指定したもので、マッチ対象がその型のインスタンスであるときにマッチする
  + マッチ対象は変数に束縛される際に自動的にキャストされる
```scala
x match {
  case s: String => "string"
  case m: Map[_, _] => "map"
  // 型消去のせいで、配列以外のコレクションの要素型までチェックすることはできない
  // case m: Map[Int, String] => "int to string"

  // 配列の場合は要素の型までチェックできる
  case as: Array[String] => "array of string"
  case a: Array[_] => "other array"
  case _ => "something else"
}
```
***

[前へ](c14.md) /
[全体目次へ戻る](index.md) /
[次へ](c16.md)
