# Scalaスケーラブルプログラミング 第33章
[全体目次へ戻る](index.md)

## 33章 パーサコンビネータ
パーサコンビネータとは、パーサを作成するための言語内DSLである。Scalaでは標準ライブラリにパーサコンビネータが含まれている。

### サンプル: 算術式
- パーサを作る前に、文法を書き出す
  + `|`は選択、`{ ... }`は0回以上の繰り返しを表す
  + expr: 式、term: 項、factor: 因子

```txt
expr ::= term { "+"term | "-" term }.
term ::= factor { "*" factor | "/" factor}.
factor ::= floatingPointNumber | "(" expr ")".
```

- 文法を書き出したら、機械的に文法の各要素をパーサコンビネータの部品に置き換えていくだけでパーサができる

```scala
import scala.util.parsing.combinator._
// JavaTokenParsersトレイトには、パーサの基本構成要素と
// 基本的な文法要素(floatingPointNumberなど)を認識するプリミティブパーサが含まれている
class Arith extends JavaTokenParsers {
  // 生成規則はメソッドとして定義される
  // 選択は"|"、連接は"~"、0回以上の繰り返しは"rep( ... )"で表現する
  def expr: Parser[Any] = term~rep("+"~term | "-"~term)
  def term: Parser[Any] = factor~rep("*"~factor | "/"~factor)
  def factor: Parser[Any] = floatingPointNumber | "("~expr~")"
}
```

### パーサの実行
- パーサクラスの`parseAll`メソッドにパーサオブジェクトと解析対象の文字列を渡すと、パーサが表現する文法に文字列全体が合致するかどうかを調べ、成功した場合は構文解析の結果を表すオブジェクトを出力する
  + `parse`メソッドは文字列の一部が合致するかどうか調べる

```scala
object ParseExpr extends Arith {
  def main(args: Array[String]): Unit = {
    println("input: " + args(0))
    println(parseAll(expr, args(0)))
  }
}
```

### 基本正規表現パーサ
- `RegexParsers`トレイトを利用すると、任意の正規表現をパーサとして使うことができる

```scala
object MyParsers extends RegexParsers {
  val ident: Parser[String] = """[a-zA-Z_]\w*""".r
}
```

### 他のパーサの使用例: JSON
- JSONの構文

```txt
value   ::= obj | arr | stringLiteral | floatingPointNumber | "null" | "true" | "false".
obj     ::= "{" [members] "}".
arr     ::= "[" values "]".
members ::= member {"," member}.
member  ::= stringLiteral ":" value.
values  ::= value {"," value}.
```

- パーサコンビネータで構成したJSONパーサ

```scala
import scala.util.parsing.combinator._
class JSON extends JavaTokenParsers {
  def value:  Parser[Any] = obj | arr | stringLiteral | floatingPointNumber | "null" | "true" | "false"
  // repsepは、第1引数のパーサが認識するトークンが第2引数の区切り文字で区切られた文字列を認識する
  def obj:    Parser[Any] = "{"~repsep(member, ",")~"}"
  def arr:    Parser[Any] = "["~repsep(value , ",")~"]"
  def member: Parser[Any] = stringLiteral~":"~value
}
```

### パーサの出力
- これまでに構成したパーサの出力は、人間にもコンピュータにも解析が困難なので、構造化したい
- パーサコンビネータに含まれる個々のパーサが返す結果値
  + 文字列をそのまま認識するパーサ: 解析した文字列自体(`String`)
  + 正規表現パーサや`JavaTokenParsers`に含まれるパーサ: 解析した文字列自体(`String`)
  + 連接`P ~ Q`: 両方の結果を含む`~`という名前のケースクラス(`~[A, B]`)
  + 選択`P | Q`: 成功した方の結果値
  + 反復`rep(P)`/`repSep(P, sep)`: すべての結果を含むリスト(`List[A]`)
  + オプション`opt(P)`: `Option[A]`。成功した場合は結果を含む`Some`、失敗した場合は`None`

- パーサの出力を所望の型のオブジェクトに変換したい
  + JSONオブジェクト: `Map[String, Any]`
  + JSON配列: `List[Any]`
  + JSON文字列: `String`
  + JSON数値リテラル: `Double`
  + `true`, `false`, `null`は同名のScalaの値にする

- `^^`演算子を利用することでパーサの出力を引数の関数で変換できる

```scala
// 浮動小数点数を解析し、マッチした文字列をDouble値に変換するパーサ
def number: Parser[Double] = floatingPointNumber ^^ (_.toDouble)
// JSONオブジェクトを表現するトークンをMapに変換
def obj: Parser[Map[String, Any]] =
  "{"~repsep(member, ",")~"}" ^^ { case "{"~ms~"}" => Map() ++ ms }
```

- `<~`や`~>`演算子を利用することで、連接を認識しつつ必要な片方の結果だけを取得できる
  + `<~`は左のパーサ、`~>`は右のパーサの結果のみを返す

```scala
// JSONオブジェクトの例を簡潔に書き換えたもの
def obj: Parser[Map[String, Any]] =
  "{" ~> repsep(member, ",") <~ "}" ^^ (Map() ++ _)
```

#### 完全なJSONパーサ

```scala
import scala.util.parsing.combinator._
class JSON extends JavaTokenParsers {
  def obj: Parser[Map[String, Any]] =
    "{" ~> repsep(member, ",") <~ "}" ^^ (Map() ++ _)
  def arr: Parser[List[Any]] =
    "[" ~> repsep(value, ",") <~ "}"
  def member: Parser[(String, Any)] =
    stringLiteral~":"value ^^ { case name~":"~value => (name, value) }
  def value: Parser[Any] =
    obj | arr | stringLiteral |
    floatingPointNumber ^^ (_.toDouble) |
    "null" ^^ (_ => null) |
    "true" ^^ (_ => true) |
    "false" ^^ (_ => false)
}
```

#### パーサコンビネータ一覧
| パーサ             | 機能                            |
|:------------------ |:------------------------------- |
| `"string"`         | リテラル                        |
| `"regexStr".r`     | 正規表現                        |
| `P ~ Q`            | 逐次合成(連接)                  |
| `P <~ Q`, `P ~> Q` | 逐次合成(片方の結果のみを返す)  |
| `P | Q`            | 選択                            |
| `opt(P)`           | オプション                      |
| `rep(P)`           | 繰り返し                        |
| `repsep(P, seq)`   | 区切り`sep`で区切られた繰り返し |
| `P ^^ f`           | 結果を関数`f`で変換             |


***

[前へ](c32.md) /
[全体目次へ戻る](index.md) /
[次へ](c34.md)
