# リーダブルコード 第14章
[全体目次へ戻る](index.md)

## 14章 テストと読みやすさ
すっきりと効果的なテストを書くための簡単な技法。ここではテストの読みやすさを中心に扱う。

### 14.1 テストを読みやすくて保守しやすいものにする
テストコードを読みやすくするのは、テスト以外のコードを読みやすくするのと同じくらい大切。テストコードは｢本物のコードの動作と使い方を示した非公式な文書｣だと考える人もいる。

テストコードが大きくて恐ろしいものだったら、以下のようなことが起きる。

- 本物のコードを修正するのを恐れる。
- 新しいコードを書いたときにテストを追加しなくなる。

コードのユーザにテストコードを安心して使ってもらい、テストコードを変更したことで既存のコードが壊れたとしても、簡単に修復できるようにしておきたい。そうすれば、安心してテストを追加できるようになる。

### 14.2 このテストのどこがダメなの?
例) 検索結果のスコアをソートしてフィルタリングする関数がある。

```cpp
// docsをスコアでソートする(降順)。マイナスのスコアは削除する
void SortAndFilterDocs(vector<ScoredDocument>* docs);
```

最初のテストは以下のようになっていた。

```cpp
void Test1() {
    vector<ScoredDocument> docs;
    docs.resize(5);
    docs[0].url = "http://example.com";
    docs[0].score = -5.0;
    docs[1].url = "http://example.com";
    docs[1].score = 1;
    // docsの初期化...

    SortAndFilterDocs(&docs);

    assert(docs.size() == 3);
    // その他のテスト...
}
```

このテストコードには少なくとも8つの問題がある。これを本章をかけて修正していく。

### 14.3 テストを読みやすくする
一般的な設計原則として、｢大切でない詳細はユーザから隠し、大切な詳細は目立つようにする｣べきだ。このテストコードでは、どうでもいい｢`vector<ScoredDocument>`の設定｣が一番目立ってしまっている。

これをキレイにするには、最初に次のようなヘルパー関数を用意する。

```cpp
void MakeScoredDoc(ScoredDocument* sd, double score, string url) {
    sd->score = score;
    sd->url = url;
}

void Test1() {
    vector<ScoredDocument> docs;
    docs.resize(5);
    MakeScoredDoc(&docs[0], -5.0, "http://example.com");
    MakeScoredDoc(&docs[1], 1, "http://example.com");
    // ...
}
```

これでも不十分だ。

- "http://example.com"というどうでもいい引数が目立っている。URLは何でもいい。
- `docs.resize(5)`, `&docs[0]`などが余計

これらを解決するために、ヘルパー関数を修正する。

```cpp
void AddScoredDoc(vector<ScoredDocument>& docs, double score) {
    ScoredDocument sd;
    sd.score = score;
    sd.url = "http://example.com";
    docs.push_back(sd);
}

void Test1() {
    vector<ScoredDocument> docs;
    AddScoredDoc(docs, -5.0);
    AddScoredDoc(docs, 1);
    // ...
}
```

だいぶ良くなったが、まだ｢楽に読み書きできる｣テストにはなっていない。新しい文書の一覧をテストしようと思ったら、コードを大量にコピペしなければいけない。

#### 最小のテストを作る
より改善するために、｢コードに思いを込める([12章](c12.md)参照)｣の技法を使う。このテストが何をしようとしているのかを簡単な言葉で説明する。

- 文書のスコアは[-5, 1, 4, -99998.7, 3]である
- `SortAndFilterDocs()`を呼び出した後のスコアは[4, 3, 1]である
- スコアはこの順番でなければならない

この説明から、一番大切なことはスコアの配列であることがわかる。テストコードは以下のようになるとよいだろう。

```cpp
CheckScoresBeforeAfter("-5, 1, 4, -99998.7, 3", "4, 3, 1");
```

テストの本質は｢こういう状況と入力からこういう振る舞いと出力を期待する｣のレベルまで要約できる。そして、これは1行でまとめられることが多い。こうすることでテストケースの追加が簡単になる。

#### 独自の｢ミニ言語｣を実装する
最近のC++では、配列リテラルをそのまま引数として渡せるようになったので、`CheckScoresBeforeAfter()`が簡単に実現できる。以前はそれができなかったので、スコアをカンマで区切った文字列を渡して、関数内でパースする必要があった。このように、文字列に別の意味をもたせるために独自の｢ミニ言語｣を定義すれば、小さな領域で多くの情報を表現できる。この定義を実現するには多くのコードを書く必要があるが、結果としてテストの追加が簡単になるのだ。

### 14.4 エラーメッセージを読みやすくする
多くの言語やライブラリには、洗練された`assert()`が用意されている。C++標準の`assert()`の代わりに、Boost C++ライブラリを使って、

```cpp
BOOST_REQUIRE_EQUAL(output, expected_output);
```

と書けば、テストが失敗したときに、以下のような詳細なメッセージが表示される。

`output == expected_output failed ["1, 3, 4"] != ["4, 3, 1"]`

もっといいエラーメッセージが欲しければ、自分で書けばいい! エラーメッセージはできるだけ役に立つようにするべきだ。自分好みのエラーメッセージを表示する｢手作りのassert｣を用意するのが最善の道かもしれない。

### 14.5 テストの適切な入力値を選択する
テストの適切な入力値を選択するには優れた技能が必要だ。適切な入力値は、コードを完全にテストするものであり、かつ最も単純なものでなければいけない。例えば、以下のように書いたとする。

```cpp
CheckScoresBeforeAfter("1, 2, 3", "3, 2, 1");
```

これは単純だが、｢マイナスのスコアを除く｣という動作がテストできてない。

#### 入力値を単純化する
すべての動作をテストしつつ入力値を単純化するには、テストに意味のある最も単純な値を選べばよい。例えば、｢マイナスの値｣であるという意味では -99998.7 も -1 も同じである。それならばよりシンプルな -1 を選んだほうがいい。その他の値についても、もっと単純な 1, 2, 3のような数値にしてかまわない。以下は、新しいバージョンのテストだ。

```cpp
CheckScoresBeforeAfter("1, 2, -1, 3", "3, 2, 1");
```

#### 1つの機能に複数のテスト
コードを検証する完璧な入力値を1つ作るのではなく、小さなテストを複数作るほうが簡単で、読みやすい。

```cpp
CheckScoresBeforeAfter("2, 1, 3", "3, 2, 1");   // ソート
CheckScoresBeforeAfter("0, -0.1, -10", "0");    // マイナスは削除
CheckScoresBeforeAfter("1, -2, 1, -2", "1, 1"); // 重複は許可
CheckScoresBeforeAfter("", "");                 // 空の入力は許可
```

- 入力値を大量に使って、バッファオーバーランなどの意図しないバグを検知するテストは役に立つ。しかし、値を直書きすると読みたくなくなる。こういう時は、プログラムで入力値を作るとよい。

### 14.6 テストの機能に名前をつける
テストコードは関数になっていることが多い。テスト関数には、テストの内容を表した名前をつけるべきだ。テストコードを読む人が、以下のことをすぐに理解できるものがいい。

- テストするクラス
- テストする関数
- テストする状況やバグ

いい名前をつけるには、まずは"Test_"という接頭辞をつけて情報をひとまとめにするといいだろう。例えば、`Test1()`ではなく、`Test_SortAndFilterDocs()`のようにテストする関数名をつける。
次に、状況に応じてテスト関数を分割するかどうかを考える。分割する場合はさらに｢テストする状況｣をテスト関数の名前につければいい。

長い名前であっても、他のコードから呼び出されることはないので構わない。テスト関数の名前はコメントだと思えばよい。テスティングフレームワークは、テストが失敗したらその関数の名前を表示するようになっているので、名前は説明的な方が役に立つ。(テスティングフレームワークによっては、メソッド名の規約があることもある)

テストコードのヘルパー関数の名前は、assertを使っているかどうかで決めればよい。例えば、 `assert()`を呼び出すヘルパー関数はすべて`Check...()`という名前にする。

### 14.7 このテストのどこがダメだったのか?
14.2節のテストコードの問題点は以下のとおりである。

1. どうでもいいことがたくさん書かれている。テストが何をしているかは1つの文で記述できる。
2. テストが簡単に追加できない。
3. 失敗メッセージが役に立たない。
4. 一度にすべてのことをテストしようとしている。テストは分割したほうが読みやすい。
5. テストの入力値が単純でない。
6. テストの入力値が不完全(スコアが0の文書は除かれる?)。
7. 極端な入力値(空のベクタ、巨大なベクタ、スコアが重複したベクタ)をテストしていない。
8. 意味のない名前が付いている。テスト関数の名前は、テストする関数や状況を表したものにするべきだ。

### 14.8 テストに優しい開発
テストしやすいコードには、明確なインタフェースがあり、検査するデータが隠されていない。あとでテストを書くつもりでコードを書くと、いいコードが書けるようになる。テストに優しい設計をすれば、振る舞いごとにうまく分割されて、自然にコードが構成されていく。

プログラムをクラスやメソッドに分割するのは、疎結合にしたほうがテストしやすいからである。外部コンポーネント(グローバル変数、読み込みが必要なライブラリ･設定ファイル)が多いと、それだけテストを書くのが面倒になる。テストしにくい設計とは、以下のようなものである。

|特性|テスト容易性の問題|設計の問題|
|:---|:-----------------|:---------|
|グローバル変数を使っている|グローバル状態をテストごとに初期化する必要がある|どの関数に副作用があるのかわかりにくい。すべてが動くことを理解するには、プログラム全体を把握する必要がある|
|多くの外部コンポーネントに依存している|最初に設定が必要なのでテストを書くのが面倒になる|依存しているものが落ちるとシステムが使えなくなる。変更の影響を理解するのが難しい など|
|コードが非決定的な動作をする|テストが当てにならない|プログラムが競合状態になったり、再現不可能なバグが発生しやすくなる。バグを追跡･修正するのが非常に難しい|

逆に、テストしやすい設計とは、以下のようなものである。

|特性|テスト容易性の問題|設計の問題|
|:---|:-----------------|:---------|
|クラスが小さい、内部状態を持たない|テストしやすい。初期設定が必要ない。検査する状態が隠されていない|単純で理解しやすい|
|クラスや関数が1つのことをしている|完全にテストするためのテストケースが少なくて済む|システムが疎結合になる|
|クラスが他のクラスにあまり依存していない|各クラスを独立してテストできる|システムを並列的に開発できる。クラスは他の部分を気にせず簡単に修正できる|
|インタフェースが明確である|明確な動作をテストできる。単純なインタフェースはテストが楽|インタフェースがわかりやすくてテストしやすい|

### 14.9 やりすぎ
場合によっては、テストに集中しすぎてしまうこともある。

- テストのために本物のコードの読みやすさを犠牲にしてしまう。
- テストのカバレッジを100%にしないと気がすまない。コードの90%をテストするほうが、残り10%をテストするよりも楽である。残りにはどうでもいいエラーケースが含まれている。その部分については、テストが割に合わないことが多い。バグのコストが高いほど、テストコードにかける時間の価値も高くなる。
- テストがプロダクト開発の邪魔になる。

***

[前へ](c13.md) /
[全体目次へ戻る](index.md) /
[次へ](c15.md)
