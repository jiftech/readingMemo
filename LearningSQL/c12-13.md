# 初めてのSQL 第12〜13章
[全体目次へ戻る](index.md)

## 12章 トランザクション
複数のユーザが同時にデータベースのデータを読んだり書いたりする際にデータの一貫性を守るための仕組みについて。

### マルチユーザーデータベース
複数のユーザがクエリやデータの変更を実行する状況では、書き込みの競合でデータが破壊されることなく、かつ読み取り時にデータが最新の状態であることが保証されなければならない。そのために、データリソースの同時使用を制御するロック機構を用いる。データベースサーバがロックを処理する際の戦略は大きく2つある。

+ 書き込みを行う際は書き込みロックを、読み取りを行う際は読み取りロックをそれぞれデータベースサーバから取得させる。複数のユーザが同時に読み取ることは可能だが、同時に書き込むことや。読み取り中の書き込み･書き込みの読み取りは禁止する。
+ 書き込みを行う際は書き込みロックを取得する必要があるが、読み取りの際は必要ない。読み取ったデータの整合性はデータベースサーバによって保証される。この手法はバージョニングと呼ばれている。

また、リソースのロック自体も、ロックされるデータの範囲(粒度)によって区別される。

+ テーブルロック: 同じテーブルのデータを同時に変更できないようにする
+ ページロック: 同じページ(記憶領域上の2~16KB程度の区間)のデータを同時に変更できないようにする
+ 行ロック: 同じ行を同時に変更できないようにする

一般にロックされるデータの範囲が広いほど、手間がかからないかわりにユーザ数が増えたときのオーバーヘッドが大きくなる。

MySQLでは、テーブルごとに使うデータベースエンジンを選択でき、利用するエンジンによってロックの戦略や粒度を選択できる。

### トランザクションとは
トランザクションは、複数のSQL文をまとめて｢全てが成功するか、全てが失敗する｣ことを保証する仕組み。トランザクションの処理の流れは以下のようになる。

+ まずトランザクションを開始する。
  - 全ての文の処理が成功した場合｢コミット｣によってトランザクションを終了する。
  - どこかで処理が失敗したり問題が起きた場合は｢ロールバック｣を行う。ロールバックは、トランザクションが開始されてから加えられた変更をすべて元に戻す命令。

また、コミットやロールバックを実行する前にデータベースサーバがシャットダウンした場合は、次の再起動の際に終了していなかったトランザクションを検索し、ロールバックする。

MySQLでは何も指定しない場合はSQL文1つ1つが1つのトランザクションになり、1つの文ごとに自動的にコミットされる。複数の文をトランザクションにまとめるには明示的に`START TRANSACTION`コマンドを発行する必要がある。トランザクションを開始した場合、SQL文でデータを変更しても`COMMIT`コマンドを発行するまでは変更は保存されないが、データを間違えて変更してしまった場合は`ROLLBACK`コマンドでトランザクション開始時点の状態に戻すことができる。

以下のような状況では、トランザクションが自動的に終了する。

+ データベースサーバがシャットダウンした場合、トランザクションは次の再起動時にロールバックされる。
+ `ALTER TABLE`などテーブルの定義を変更するSQLスキーマ文を発行した場合、現在のトランザクションはコミットされ、新しいトランザクションが開始される。
+ トランザクション内で新しい`START TRANSACTION`コマンドを発行した場合、現在のトランザクションは自動的にコミットされて終了する。
+ デッドロックが検出され、その原因がトランザクションだと判断された場合、トランザクションはロールバックされる。

トランザクション内で問題が発生したが、ロールバックによって全ての変更を元に戻すのは避けたいという場合は、トランザクションにセーブポイントを設定する。セーブポイントには名前を付けることができ、必要なときに名前を指定してそのセーブポイントの時点まで変更を戻すことができる。

MySQLでは`SAVEPOINT <名前>`コマンドでセーブポイントを設定でき、`ROLLBACK TO SAVEPOINT <名前>`で指定したセーブポイントの時点まで変更を戻す。

## 13章 インデックスと制約
### インデックス
通常、データベースサーバがテーブルに行を挿入する際は何かを基準に順番に並べたりせず、次に利用できる場所にデータを配置するだけである。よって、そのテーブルへのクエリが実行されたときにその答えを得るには全ての行を走査しなければならない。行数が増えるとこの戦略では時間がかかりすぎてしまう。

これを解決するには、テーブルにインデックス(索引)を作成すれば良い。データベースにおけるインデックスは、テーブルのある列の値(インデックステーブルはこの値を基準にソートされている)と、その値を含む行が配置されている場所を示す情報を含む特別なテーブルであり、データベースサーバはインデックスを頼りに目的の行を探し当てることができる。

### インデックスの作成
MySQLにおいてテーブルにインデックスを作成･削除する方法は以下のようになる。

```sql
/* ALTER TABLE <テーブル名> ADD INDEXのあとにインデックス名とインデックスの基準となる列名を指定 */
ALTER TABLE table
ADD INDEX idx_name (column1, ...);

/* 削除はDROP INDEXを使う */
ALTER TABLE table
DROP INDEX idx_name;
```

インデックスが作成されているテーブルでは、クエリオプティマイザはインデックスを利用するのが有利な場合はインデックスを利用して行を検索する。複数のインデックスが作成されている場合は、最適なインデックスを選択する。

#### 一意なインデックス
テーブルのある列に一意なインデックスを作成すると、通常のインデックスの効果に加え、その列に重複する値を挿入できなくなる。この制限は主キー制約と同様なので、主キーの列に一意なインデックスを作成することはあまりない。

```sql
/* 一意なインデックスを作成するにはADD UNIQUEを使う */
ALTER TABLE table
ADD UNIQUE idx_name (column1, ...);
```

#### 複数列のインデックス
複数の列にまたがるインデックスを作成することもできる。例えば銀行員を管理するテーブルで、行員の姓名を用いて行を検索したいならば、姓と名の2つの列にインデックスを作成する。このインデックスは姓名の両方を指定するクエリや姓だけを指定するクエリではうまくいくが、名だけを指定するクエリでは利用できない。複数列のインデックスでは、列を指定する順番に注意する必要がある。

### インデックスの種類
+ B-Treeインデックスは、多くのデータベースサーバでデフォルトで作成される種類のインデックスである。木構造の一種で、葉までの深さが全体として均等になるようにデータが挿入されていく。
+ ビットマップインデックスは、ある列に入る可能性のある値の種類が少ない(値の集合の濃度が低い)ときにB-Treeを上回る効果を発揮する。ある列のとりうる値ごとに、その値が格納されている行の場所に1、それ以外の場所に0が入ったビットマップが用意される。
+ テキストインデックスは、データベースに大きなドキュメントが格納されており、そのドキュメント内の語句を検索できる必要があるときに用いられる。

### インデックスの欠点
テーブルに更新があるたびに、そのテーブルに作成されたインデックスも更新する必要があるので、インデックスをむやみに増やすとデータベースサーバへの負担も大きくなっていくことに注意する必要がある。最も効果的な戦略は、作業で必要になったらインデックスを作成し、その作業が終わったら削除するという方法である。

### 制約
制約とは、テーブルの列の値に関する制限で、以下の4種類がある。
+ 主キー制約: ある列(または列の組)を、テーブルにおいて一意に行を特定できるような値(値の組)として指定する。その列に重複する値(値の組)やnull値を挿入できなくする。
+ 外部キー制約: テーブルの列の値を、別のテーブルの主キー列に含まれている値だけに制限する。
+ 一意制約: 1つ以上の列にテーブル内で一意な値が含まれるように制限する。
+ 検査制約: 列に設定できる値を、指定されたものに制限する。

制約はテーブルを作成するときに指定する。

```sql
/* CONSTRAINT <制約名> のあとに、主キー制約ならPRIMARY KEY, 外部キー制約ならFOREIGN KEYを指定し、その後に指定する列の名前を置く。 */
/* 外部キー制約の場合はさらにREFERENCESに続けて参照するテーブル名と列名を置く。 */
/* 一意制約は列の定義の最後にUNIQUEをつけることで指定できる。 */
/* 検査制約は、MySQLでは設定しても強制されないので注意。 */
CREATE TABLE table
  (...
  column_n data_type_n UNIQUE,
  ...
  CONSTRAINT fk_name FOREIGN KEY (column_a)
    REFERENCES ref_table (ref_column),
  CONSTRAINT pk_name PRIMARY KEY (column_b)
  );

/* 既存のテーブルに制約を加える場合はALTER TABLEでADD <制約>と指定すれば良い。*/
/* 制約を削除するにはADDのかわりにDROPを指定する。 */
ALTER TABLE table
ADD CONSTRAINT pk_name PRIMARY KEY (column_a);
```

#### 制約とインデックス
制約を作成すると、データベースサーバによっては自動的にインデックスが作成される。MySQLの場合は主キー制約や一意制約を設定した時に一意なインデックスが、外部キー制約を設定した時に通常のインデックスが作成される。

### 制約の連鎖
外部キー制約が設定されている場合、その列の値が参照しているテーブルの主キーのどの値とも一致しないような行を挿入したり、更新したりするとエラーになる。逆に、デフォルトでは、参照されている側のテーブルで既に参照されている列の値を変更しようとするとエラーになるが、外部キー制約に｢連鎖更新｣のオプションを追加すると、参照されている側の値を変更した際にその列を参照している側の列にその変更を反映するという形でデータの一貫性を保つことができる。連鎖更新を行うようにするには、外部キーを設定する際に`ON UPDATE CASCADE`を追加する。

｢連鎖削除｣を指定することもできる。これは、参照されている側の値を削除したときにそれを参照している行を一緒に削除するもので、外部キーを設定する際に`ON DELETE CASCADE`を追加すればよい。

***

[前へ](c11.md) /
[全体目次へ戻る](index.md) /
[次へ](a_b.md)
