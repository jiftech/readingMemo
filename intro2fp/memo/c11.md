# 関数プログラミング入門 Haskellで学ぶ原理と技法 第11章
[全体目次へ戻る](../index.md)

## 11章 構文解析
### 連接
- 構文解析器を「文字列を入力としてとり、『解析結果と未消費の文字列の対』のリストを出力として返す関数」と考える
  + リストの各要素は、ありうる全ての場合を表す

```haskell
newtype Parser a = MkP (String -> [(a, String)])

apply :: Parser a -> String -> [(a, String)]
apply (MkP f) s = f s

-- 解析結果を1つだけ返す関数
applyParser :: Parser a -> String -> a
applyParser p = fst . head . apply p

-- Parserをモナドのインスタンスにできる
instance Monad Parser where
  return x = MkP f where f s = [(x, s)]
  p >>= q  = MkP f
    where f s = [(y, s'') | (x, s') <- apply p s, (y, s'') <- apply (q x) s']
```

- Parserをモナドとしたので`do`記法を使って構文解析器を複合できる。まずは基本となる構文解析器を定義する

```haskell
-- 最初の1文字を読み込む。入力が全て消費されていれば失敗
item :: Parser Char
item MkP f
  where f []       = []
        f (c : cs) = [(c, cs)]

-- 常に失敗する
zero :: Parser a
zero = MkP f where f s = []

-- 与えられた条件を満たす文字を読み込む
sat :: (Char -> Bool) -> Parser Char
sat p = do
  c <- item
  if p c then return c else zero

char :: Char -> Parser ()
char x = do
  c <- sat (== x)
  return ()

string :: String => Parser ()
string [] = return ()
string (x : xs) = do
  char x;
  string xs;
  return ()

lower :: Parser Char
lower = sat isLower

digit :: Parser Int
digit = do
  d <- sat isDigit
  return (ord d - ord '0')     
```
***

[前へ](c10.md) /
[全体目次へ戻る](../index.md) /
[次へ](c12.md)
