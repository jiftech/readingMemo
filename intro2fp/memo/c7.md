# 関数プログラミング入門 Haskellで学ぶ原理と技法 第7章
[全体目次へ戻る](../index.md)

## 7章 効率
### 遅延評価
- 式の簡約には最内簡約と最外簡約という2つの方針がある
  + 最内簡約では、各ステップで「最内リデックス(redex, 簡約可能式)」が簡約される
    * 最内リデックスとは、内側に別のリデックスを含まないリデックスのこと
  + 最外簡約では、各ステップで「最外リデックス」が簡約される
    * 最外リデックスとは、外側の別のリデックスに含まれていないリデックスのこと

- 式に正規形(それ以上簡約できない形)があれば、最外簡約は必ず停止する
  + このため、最外簡約は「正規順序簡約」とも呼ばれる

- 最外簡約は、関数定義の中に同じ引数が複数回出現したときに最内簡約よりも多くのステップが必要となる
- ステップ数を削減するには、式を木ではなくグラフで表現する
  + 同じ引数が同じ場所を参照するような形式。重なった部分式を共有することで、簡約回数を節約する

- 式の表現にグラフを用いたときの最外簡約を「最外グラフ簡約」といい、よく「遅延評価」と呼ばれる
- 最内簡約は「先行評価」と呼ばれることが多い

### 漸近的解析
- 通常は、ある関数の1つの定義と別の定義の実行効率を比べる
  + 例: 以下の`reverse`と`reverse'`
  + `reverse`はリストの長さ`n`の2乗に比例したステップ数がかかる一方、`reverse'`は`n`に比例したステップ数しかかからない

```haskell
-- O(n^2)
reverse []       = []
reverse (x : xs) = reverse xs ++ [x]

-- O(n)
reverse' = foldl prefix [] where prefix xs x = x : xs
```

- 遅延評価で必要となるステップ数は、先行評価の場合を超えることはない


### 蓄積引数
- リストの連結`(++)`の計算量は左のリストの長さに比例する。これは「高価」であり、除去したい
- 関数の引数を1つ追加することで`(++)`を除去できることがある
  + `(++) = foldr consdot id where consdot x g = (x :) . g`という式に基づく変形

```haskell
-- xsを逆にして結合する
revcat :: [a] -> [a] -> [a]
revcat xs ys = reverse xs ++ ys

-- ++を除去したバージョン
revcat' [] ys = ys
revcat' (x : xs) ys = revcat' xs (x : ys)
```

- 二分木の平坦化

```haskell
-- 素朴な定義
-- 木に含まれる葉の数をsとしたとき、計算量O(s log s)
flatten :: Btree a -> [a]
flatten (Leaf x) = [x]
flatten (Fork xt yt) = flatten xt ++ flatten yt

-- flatten xt = flatcat xt []
-- このように定義すると計算量がO(s)で済む
flatcat :: Btree a -> [a] -> [a]
-- flatcat xt xs = flatten xt ++ xs
flatcat (Leaf x) xs = x : xs
flatcat (Fork xt yt) xs = flatcat xt (flatcat yt xs)
```


### タプリング法
- 「結果を追加」することで関数を一般化することで、計算量を改善する
  + 蓄積引数の技法と双対関係にあるプログラム最適化手法

- 蓄積変数も、タプリング法も、やっていることは「無駄な計算を節約するために、途中の計算結果をメモ化する」ということ
  + その場所が関数の引数か、返り値かの違いでしかない


### 空間の制御
- 最外簡約だけを使うと、大きな式を簡約するために非常に大きな空間を消費することになる
  + 最内簡約と最外簡約をうまく組み合わせれば、使用する空間量を削減できる

- 式`e`が関数であるか、0個以上の引数に適用されたデータ構成子であるとき`e`は「頭部正規形」であるという
  + 例: `e1 : e2`, `Fork e1 e2`, `(e1, e2)`は全て頭部正規形である

- `strict f e`という関数は`e`を頭部正規形にしてから関数`f`を適用する

```haskell
strict f x = if x = _|_ then _|_ else f x
```

- `f == strict f`であるのは`f`が正格関数(`f _|_ = _|_`)であるときかつそのときに限る
- `f`が正格だが、どこにも`_|_`が現れない場合、`f e`の簡約結果と`strict f e`の簡約結果は等しく、必要ステップ数も変わらない
  + `strict`を利用し、意味と時間計算量を変えずに空間計算量を改善できることがある

#### 畳み込み再考
- 第1双対定理: `<+>`が結合的で単位元`e`を持つならば、`foldr == foldl`
  + しかし、どちらを使うかによって時間・空間計算量は異なる可能性がある

- `<+>`が両方の引数に関して正格で、時間計算量・空間計算量ともにO(1)のとき: `foldr`, `foldl`どちらも時間計算量O(n)
  + `strict`を用いると空間計算量をO(1)にできる
- `<+>`が上の性質を満たさず、どちらかの引数に対して非正格なとき: 経験則によれば`foldr`のほうが効率が良い


### 融合変換・有限差分法・デフォレステーション
- いずれも、複数の関数を合成して効率を向上する手法
  + 有限差分法: `f . (g x) == (h x) . f`のとき`f . foldr g a == foldr h (f a)`という関係を利用した変換手法
  + デフォレステーション: 融合変換を利用し、プログラムから中間データ構造の生成を除去して効率化する手法

***

[前へ](c6.md) /
[全体目次へ戻る](../index.md) /
[次へ](c8.md)
